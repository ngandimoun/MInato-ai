// FILE: lib/core/orchestrator.ts
import { randomUUID } from "crypto";
import OpenAI from "openai";
import type { ChatCompletionMessageToolCall } from "openai/resources/chat/completions";
import { CompanionCoreMemory } from "../../memory-framework/core/CompanionCoreMemory";
import {
MemoryFrameworkMessage,
UserState,
AnyToolStructuredData,
ChatMessage,
OrchestratorResponse,
StoredMemoryUnit,
ReminderDetails,
PredefinedPersona,
UserPersona,
OpenAITtsVoice,
ExtractedInfo,
ChatMessageContentPart,
ChatMessageContentPartText,
ResponseApiInputContent,
MessageAttachment,
ChatMessageContentPartInputImage,
XmlPlan, 
XmlQueryClassification, 
XmlVerification, 
XmlParallelExecutionPlan,
XmlNluAnalysis
} from "@/lib/types/index";
import { BaseTool, ToolInput, ToolOutput, OpenAIToolParameterProperties } from "../tools/base-tool";
import { tools as appToolsRegistry, resolveToolName } from "../tools/index";
import { MemoryTool } from "../tools/MemoryTool";
import { TTSService } from "../providers/tts_service";
import { STTService } from "../providers/stt_service";
import { VideoAnalysisService } from "../services/VideoAnalysisService";
import { supabaseAdmin } from "../supabaseClient";
import { getSupabaseAdminClient } from "../supabase/server";
import { Security } from "../utils/security";
import {
MAX_CHAT_HISTORY,
SESSION_ID_PREFIX,
DEFAULT_USER_NAME,
MEMORY_SEARCH_LIMIT_DEFAULT,
DEFAULT_PERSONA_ID,
DEFAULT_TOOL_TIMEOUT_MS,
MEDIA_UPLOAD_BUCKET,
} from "../constants";
import { appConfig, injectPromptVariables } from "../config";
import {
generateAgentResponse,
generateStructuredJson,
generateVisionCompletion,
resolveToolNameWithLLM,
} from "../providers/llm_clients";
import { 
TOOL_ROUTER_PROMPT_TEMPLATE, 
RESPONSE_SYNTHESIS_PROMPT_TEMPLATE,
MINATO_PLANNER_PROMPT_TEMPLATE, 
MINATO_VERIFIER_PROMPT_TEMPLATE, 
MINATO_QUERY_NATURE_CLASSIFIER_PROMPT_TEMPLATE,
MINATO_PARALLEL_TOOL_EXECUTION_PROMPT_TEMPLATE,
MINATO_NLU_INTENT_DISAMBIGUATION_PROMPT_TEMPLATE
} from "../prompts";
import { logger } from "../../memory-framework/config";
import { safeJsonParse } from "../../memory-framework/core/utils";
import { CompletionUsage } from "openai/resources";
import Ajv from "ajv";
import type { ValidateFunction } from "ajv";
import { 
parseClassificationFromXml, 
parsePlanFromXml, 
parseParallelExecutionPlanFromXml, 
parseVerificationFromXml, 
parseNluAnalysisFromXml
} from '../utils/xml-processor';
import { getToolDescriptionsForPlanner, validateToolArgs, sortExecutionGroupsByDependencies } from './orchestration-helpers';
import { stripSystemPrefixes, getFirstOrchResponse } from './helpers';
import { analyzeUserQuery, runNluDisambiguation } from './nlu-disambiguation';
import { featureFlags } from '../config';
// Role-based personalization has been disabled
// import { enhanceUserMemoryContext, processTextMessageWithPersonalization } from "../utils/personalization";
import { runEnhancedOrchestration } from './runEnhancedOrchestration';

// Remove duplicate imports that were added below this line
type SdkResponsesApiTool = OpenAI.Chat.Completions.ChatCompletionTool;
type SdkResponsesApiFunctionCall = ChatCompletionMessageToolCall;

type ToolRouterPlanStep = {
tool_name: string;
arguments: Record<string, any>;
reason: string;
};
type ToolRouterPlan = {
planned_tools: ToolRouterPlanStep[];
};
const TTS_INSTRUCTION_MAP: Record<string, string> = {
neutral: "Tone: Warm, Pace: Natural, Pitch: Medium",
greeting: "Tone: Friendly and welcoming, Pace: Natural, Pitch: Medium",
farewell: "Tone: Warm and concluding, Pace: Natural, Pitch: Slightly lower",
confirmation_positive: "Tone: Affirming and clear, Pace: Natural, Pitch: Medium",
confirmation_negative: "Tone: Neutral but clear, Pace: Natural, Pitch: Medium",
clarification: "Tone: Inquisitive and helpful, Pace: Slightly slower, Pitch: Rising slightly",
celebratory: "Tone: Excited, Pace: Slightly faster, Emphasis: Moderate (20%), Pitch: Slightly higher",
happy: "Tone: Bright, Pace: Natural, Pitch: Slightly higher",
encouraging: "Tone: Supportive, Pace: Natural, Volume: Slightly softer",
apologetic: "Tone: Soft, Pace: Slower, Pauses: Moderate, Pitch: Slightly lower",
empathy: "Tone: Caring and understanding, Pace: Gentle, Pitch: Soft",
concerned: "Tone: Serious, Pace: Slightly slower, Pitch: Slightly lower, Volume: Normal",
disappointed: "Tone: Subdued, Pace: Slower, Pitch: Lower, Volume: -5%",
urgent: "Tone: Firm, Pace: Rapid, Volume: +10%, Emphasis: Strong (30%)",
calm: "Tone: Soothing, Pace: Slower, Volume: -5%",
gentle: "Tone: Soft, Pace: Slower, Pitch: Medium-Low",
informative: "Tone: Clear, Pace: Natural, Volume: Normal",
instructional: "Tone: Clear and guiding, Pace: Deliberate, Pitch: Medium",
questioning: "Tone: Curious, Pace: Natural, Intonation Contour: Rising at end",
assertive: "Tone: Confident, Pace: Natural, Volume: +5%",
formal: "Tone: Neutral-Serious, Pace: Measured, Articulation: Precise",
whispering: "Tone: Breathy, Volume: -40%, Pace: Natural, Pitch: Low",
sarcastic: "Tone: Exaggeratedly Sweet OR Flat/Monotone, Pace: Maybe slightly slower, Emphasis: Unusual stress",
humorous: "Tone: Playful, Pace: Variable, Pitch: Variable highs/lows, Emphasis: Playful stress",
roasting: "Tone: Playful Teasing OR Mock-Serious, Pace: Slightly faster, Emphasis: Pointed but light",
flirtatious: "Tone: Playful-Warm, Pace: Slightly slower, Pitch: Slightly lower, Breathiness: Slight increase",
intimate: "Tone: Soft, Warm, Pace: Slower, Pitch: Low, Volume: -15%, Breathiness: Moderate",
thinking: "Tone: Neutral, Pace: Slowed, Pauses: Frequent short pauses",
error: "Tone: Neutral and informative, Pace: Clear, Pitch: Medium",
workflow_update: "Tone: Neutral and informative, Pace: Natural, Pitch: Medium",
};
const DEFAULT_INSTRUCTIONS = TTS_INSTRUCTION_MAP.neutral;
type DebugFlowType = NonNullable<NonNullable<OrchestratorResponse["debugInfo"]>["flow_type"]>;
function getDynamicInstructions(intentType?: string | null): string {
if (intentType && TTS_INSTRUCTION_MAP[intentType]) {
return TTS_INSTRUCTION_MAP[intentType];
}
logger.warn(`[Orch getDynamicInstructions] Unknown intent type "${intentType}", using default.`);
return DEFAULT_INSTRUCTIONS;
}
function summarizeChatHistory(history: ChatMessage[], maxLength: number = 1000): string {
if (!history || history.length === 0) return "No recent conversation history.";
return history.slice(-MAX_CHAT_HISTORY * 2)
.map((msg) => {
let contentPreview = "";
if (typeof msg.content === 'string') {
contentPreview = msg.content.substring(0, 100) + (msg.content.length > 100 ? "..." : "");
} else if (Array.isArray(msg.content)) {
const textPartObject = msg.content.find((p): p is ChatMessageContentPartText => p.type === "text");
const textPart = textPartObject?.text;
const imagePart = msg.content.find((p) => (p as any).type === "input_image" || (p as any).type === "image_url");
contentPreview = textPart ? textPart.substring(0, 80) + (textPart.length > 80 ? "..." : "") : "";
if (imagePart) contentPreview += " [Image Present]";
} else if ((msg as any).tool_calls) {
contentPreview = `Tool Call: ${(msg as any).tool_calls[0]?.function?.name || "unknown"}`;
} else if (msg.role === "tool") {
contentPreview = `Tool Result for ${msg.name || (msg as any).tool_call_id?.substring(0, 6) || "unknown"}`;
}
const roleDisplay = msg.role === "assistant" ? "Minato" : msg.role.charAt(0).toUpperCase() + msg.role.slice(1);
return `${roleDisplay}: ${contentPreview || "[Empty/Non-Text Content]"}`;
})
.join("\n")
.substring(0, maxLength);
}
function isValidOpenAITtsVoice(voice: string | null | undefined): voice is OpenAITtsVoice {
if (!voice) return false;
return (appConfig as any).openai.ttsVoices.includes(voice);
}
function sanitizeToolParameterSchemaForOpenAI(originalSchema: BaseTool['argsSchema']): OpenAI.FunctionDefinition["parameters"] {
  if (!originalSchema || originalSchema.type !== 'object' || !originalSchema.properties) {
    return { type: "object", properties: {}, additionalProperties: false };
  }
  
  // Ensure all properties can be null to handle OpenAI's schema validation
  const properties: Record<string, any> = {};
  for (const [key, prop] of Object.entries(originalSchema.properties)) {
    if (typeof prop === 'object') {
      if (prop.type === 'string') {
        // Convert string type to accept both string and null
        properties[key] = {
          ...prop,
          type: ["string", "null"]
        };
      } else if (prop.type === 'number') {
        // Convert number type to accept both number and null
        properties[key] = {
          ...prop,
          type: ["number", "null"]
        };
      } else if (prop.type === 'boolean') {
        // Convert boolean type to accept both boolean and null
        properties[key] = {
          ...prop,
          type: ["boolean", "null"]
        };
      } else if (prop.type === 'array') {
        // Convert array type to accept both array and null
        properties[key] = {
          ...prop,
          type: ["array", "null"]
        };
      } else {
        properties[key] = prop;
      }
    } else {
      properties[key] = prop;
    }
  }
  
  return {
    type: "object",
    properties: properties,
    required: originalSchema.required || [],
    additionalProperties: false, // Always set to false for OpenAI
  };
}
const PLANNING_MODEL_NAME_ORCH = (appConfig as any).openai.planningModel;
const CHAT_VISION_MODEL_NAME_ORCH = (appConfig as any).openai.chatModel;
function summarizeUserStateForWorkflow(userState: UserState | null, maxLength: number = 200): string {
if (!userState) return "No user state.";
const parts: string[] = [];
if (userState.user_first_name) parts.push(`Name: ${userState.user_first_name}`);
if (userState.preferred_locale) parts.push(`Locale: ${userState.preferred_locale}`);
if (userState.latitude && userState.longitude) parts.push(`Loc: ~${userState.latitude.toFixed(1)},${userState.longitude.toFixed(1)}`);
if (userState.timezone) parts.push(`TZ: ${userState.timezone}`);
if (userState.active_persona_id) parts.push(`Persona: ${userState.active_persona_id}`);
const personaTraits = (userState as any)?.active_persona_traits?.join(', ') || 'helpful, friendly';
parts.push(`Traits: ${personaTraits}`);
return parts.join(" | ").substring(0, maxLength) || "Basic user state.";
}
function chatMessageContentPartsToMessageParts(parts: ChatMessageContentPart[]): import("../../memory-framework/core/types").MessagePart[] {
return parts.map((p) => {
if (p.type === "text") {
return { type: "text", text: p.text };
} else if (p.type === "input_image") {
return { type: "image_url", image_url: { url: p.image_url, detail: p.detail } };
} else {
const exhaustiveCheck: never = p;
logger.warn(`[Orch chatMessageContentPartsToMessageParts] Unsupported part type: ${(p as any).type}`);
return { type: "text", text: "[Unsupported content]" };
}
});
}
// --- In-memory Tool Execution Log (DEV/DEBUG ONLY) ---
// This log is NOT persistent and is for development/debugging only.
const TOOL_EXECUTION_LOG_MAX = 500;
const toolExecutionLog: Array<{
  timestamp: number;
  toolName: string;
  aliasUsed?: string;
  arguments: Record<string, any>;
  result?: any;
  error?: any;
  userId?: string;
  structuredData?: any;
  success: boolean;
}> = [];

/**
 * Add a tool execution entry to the in-memory log (circular buffer, dev only)
 */
function logToolExecution(entry: {
  toolName: string;
  aliasUsed?: string;
  arguments: Record<string, any>;
  result?: any;
  error?: any;
  userId?: string;
  structuredData?: any;
  success: boolean;
}) {
  if (toolExecutionLog.length >= TOOL_EXECUTION_LOG_MAX) toolExecutionLog.shift();
  toolExecutionLog.push({ ...entry, timestamp: Date.now() });
}

/**
 * Get tool execution history (dev only, not persistent)
 */
export function getToolExecutionHistory({ limit = 20, offset = 0, toolName, userId, success }: { limit?: number; offset?: number; toolName?: string; userId?: string; success?: boolean }) {
  let filtered = toolExecutionLog;
  if (toolName) filtered = filtered.filter(e => e.toolName === toolName);
  if (userId) filtered = filtered.filter(e => e.userId === userId);
  if (typeof success === 'boolean') filtered = filtered.filter(e => e.success === success);
  return {
    total: filtered.length,
    entries: filtered.slice(Math.max(0, filtered.length - offset - limit), filtered.length - offset).reverse(),
  };
}

// --- Per-user/session tool call count tracking (in-memory, not persistent) ---
const toolCallCounts: { [userId: string]: { [toolName: string]: number } } = {};
// --- Per-user, per-tool rate limit tracking (timestamps of calls) ---
const toolCallTimestamps: { [userId: string]: { [toolName: string]: number[] } } = {};

export class Orchestrator {
  private ttsService = new TTSService();
  private sttService = new STTService();
  private videoAnalysisService = new VideoAnalysisService();
  private toolRegistry: { [key: string]: BaseTool };
  private memoryFramework: CompanionCoreMemory;
  private availableToolsForRouter: SdkResponsesApiTool[] = [];
  private toolNameResolutionCache: Map<string, string> = new Map();
  constructor() {
    logger.info(`[Orch] Initializing Orchestrator (Planning: ${PLANNING_MODEL_NAME_ORCH}, Chat/Vision: ${CHAT_VISION_MODEL_NAME_ORCH}, Max ${(appConfig.openai.maxToolsPerTurn || 3)} Tools/Turn)...`);
    try {
      this.memoryFramework = new CompanionCoreMemory();
      logger.info("[Orch] Memory Framework initialized.");
    } catch (memError: any) {
      logger.error(`[Orch] CRITICAL: Failed init Memory Framework: ${memError.message}`, memError.stack);
      throw new Error(`Memory init failed: ${memError.message}`);
    }
    const memoryToolInstance = new MemoryTool(this.memoryFramework);
    this.toolRegistry = {
      ...appToolsRegistry,
      [memoryToolInstance.name]: memoryToolInstance,
    };
    this.availableToolsForRouter = Object.values(this.toolRegistry)
    .filter(tool => (tool as BaseTool).enabled !== false)
    .map(tool => ({
      type: "function",
      function: {
        name: tool.name,
        description: tool.description,
        parameters: sanitizeToolParameterSchemaForOpenAI(tool.argsSchema)
      }
    }));
    // Add video-specific tool descriptions
    const videoToolDescriptions = [
      "VideoAnalysisTool: Analyzes video content including objects, actions, and visual themes",
      "MakeupAssistantTool: Provides makeup tips and product recommendations based on visual analysis"
    ];
    logger.info(`[Orch] Video tools registered: ${videoToolDescriptions.join(', ')}`);
    const toolNamesForRouter = this.availableToolsForRouter.map(t => (t.type === 'function' ? t.function.name : t.type)).filter(name => name);
    logger.info(`[Orch] Registered tools for Router (${toolNamesForRouter.length}): ${toolNamesForRouter.join(', ')}`);
  }
  private async logInteraction(logData: Partial<{ /* ... */ }>, isUpdate: boolean = false, logIdToUpdate?: number | null): Promise<number | null> { return null; }
  private async getUserFirstName(userId: string): Promise<string> {
    if (!userId) {
      logger.warn("[Orch getUserFirstName] No userId.");
      return DEFAULT_USER_NAME;
    }
    try {
      const state = await supabaseAdmin.getUserState(userId);
      if (state?.user_first_name?.trim()) return state.user_first_name.trim();
      const profile = await supabaseAdmin.getUserProfile(userId);
      return (
        profile?.first_name?.trim() ||
        profile?.full_name?.trim()?.split(" ")[0] ||
        DEFAULT_USER_NAME
      );
    } catch (error: any) {
      logger.warn(`[Orch getUserFirstName] Failed fetch for user ${userId.substring(0, 8)}: ${error.message}`);
      return DEFAULT_USER_NAME;
    }
  }

  /**
   * Get user state from Supabase
   * @param userId User ID
   * @returns User state object or null if not found
   */
  private async getUserState(userId: string): Promise<UserState | null> {
    if (!userId) {
      logger.warn("[Orch getUserState] No userId.");
      return null;
    }
    
    try {
      return await supabaseAdmin.getUserState(userId);
    } catch (error: any) {
      logger.warn(`[Orch getUserState] Failed fetch for user ${userId.substring(0, 8)}: ${error.message}`);
      return null;
    }
  }
  
  private validateToolStep(step: ToolRouterPlanStep): boolean {
    const tool = this.toolRegistry[step.tool_name];
    if (!tool) {
      logger.error(`Tool ${step.tool_name} not registered`);
      return false;
    }
    if (tool.argsSchema) {
      const ajv = new Ajv();
      const validate: ValidateFunction = ajv.compile(tool.argsSchema);
      if (!validate(step.arguments)) {
        logger.error(`Invalid arguments for ${step.tool_name}:`,
          JSON.stringify(validate.errors));
        return false;
      }
    }
    return true;
  }
  private async executeToolCalls(
    userId: string,
    currentTurnUserInput: string, // ADDED: Explicit user input for the current turn
    toolCallsFromRouter: ToolRouterPlanStep[],
    apiContext: Record<string, any>,
    userState: UserState | null,
    history: ChatMessage[]
  ): Promise<{ messages: ChatMessage[]; lastSuccessfulStructuredData: AnyToolStructuredData | null; llmUsage: null; toolResultsSummary: string; clarificationQuestion?: string | null; clarificationDetails?: any }> {
    const logPrefix = `ToolExecutor User:${userId.substring(0, 8)} Sess:${apiContext?.sessionId?.substring(0, 6)}`;
    const toolResultsMessages: ChatMessage[] = [];
    const structuredDataMap: Map<string, AnyToolStructuredData | null> = new Map();
    let toolResultsSummaryParts: string[] = [];
    let clarificationQuestion: string | null = null;
    let clarificationDetails: any = null;
    const now = Date.now();
    const MS_PER_MINUTE = 60 * 1000;
    const MS_PER_HOUR = 60 * MS_PER_MINUTE;
    const MS_PER_DAY = 24 * MS_PER_HOUR;
    // --- Per-user/session tool call count logic ---
    if (!toolCallCounts[userId]) toolCallCounts[userId] = {};
    const executionPromises = toolCallsFromRouter
    .map(async (routedToolCall) => {
        const toolNameFromRouter = routedToolCall.tool_name;
        const callId = `toolcall_${randomUUID()}`;
        // Always resolve the tool name to the canonical tool instance
        const tool = resolveToolName(toolNameFromRouter);
        if (!tool) {
          logger.warn(`${logPrefix} Tool '${toolNameFromRouter}' could not be resolved to a registered tool. Skipping.`);
          toolResultsSummaryParts.push(`Error: Tool '${toolNameFromRouter}' is not available or recognized.`);
          return {
            role: "tool" as const,
            tool_call_id: callId,
            name: toolNameFromRouter,
            content: `Error: Tool '${toolNameFromRouter}' is not available or recognized by Minato.`,
          };
        }
        const canonicalToolName = tool.name;
        // PATCH/FALLBACK LOGIC FOR MISSING REQUIRED ARGUMENTS (e.g., 'query')
        let actualToolArgs = JSON.parse(JSON.stringify(routedToolCall.arguments || {}));
        
        // Filter arguments to only include properties defined in this tool's schema
        if (tool.argsSchema && tool.argsSchema.properties) {
          const validProps = Object.keys(tool.argsSchema.properties);
          const filteredArgs: Record<string, any> = {};
          
          // Only include properties that are defined in this tool's schema
          for (const prop of validProps) {
            if (prop in actualToolArgs) {
              filteredArgs[prop] = actualToolArgs[prop];
            }
          }
          
          actualToolArgs = filteredArgs;
        }
        
        // Move userInputForFallback up so it's always available
        // Use the new currentTurnUserInput as the primary source
        let userInputForFallback = stripSystemPrefixes(currentTurnUserInput);
        if (!userInputForFallback) {
          // Try to extract from history if currentTurnUserInput was somehow empty
          const lastUserMsg = Array.isArray(history) ? history.slice().reverse().find(m => m.role === 'user' && m.content && (typeof m.content === 'string' || (Array.isArray(m.content) && m.content.some(p => p.type === 'text')))) : null;
          if (lastUserMsg) {
            if (typeof lastUserMsg.content === 'string') {
              userInputForFallback = lastUserMsg.content.trim();
            } else if (Array.isArray(lastUserMsg.content)) {
              const textPart = lastUserMsg.content.find(p => p.type === 'text') as ChatMessageContentPartText | undefined;
              userInputForFallback = textPart?.text.trim() || '';
            }
          } else {
            userInputForFallback = '';
          }
        }
        // As a last resort, try to use routedToolCall.reason if it contains the user query
        if (!userInputForFallback && typeof routedToolCall.reason === 'string' && routedToolCall.reason.trim()) {
          userInputForFallback = routedToolCall.reason;
        }
        // Or try to use a string from routedToolCall.arguments if any
        if (!userInputForFallback && routedToolCall.arguments) {
          const argString = Object.values(routedToolCall.arguments).find(v => typeof v === 'string' && v.trim());
          if (argString) userInputForFallback = argString;
        }
        // --- BEGIN: NewsAggregatorTool-specific fallback for required arguments ---
        if (canonicalToolName === "NewsAggregatorTool") {
          // Filter arguments to only include properties defined in NewsAggregatorTool's schema FIRST
          if (tool.argsSchema && tool.argsSchema.properties) {
            const validProps = Object.keys(tool.argsSchema.properties);
            const filteredOriginalArgs: Record<string, any> = {};
            
            // Only include properties that are defined in NewsAggregatorTool's schema
            for (const prop of validProps) {
              if (prop in routedToolCall.arguments) {
                filteredOriginalArgs[prop] = routedToolCall.arguments[prop];
              }
            }
            
            // Use filtered arguments as the base
            actualToolArgs = JSON.parse(JSON.stringify(filteredOriginalArgs));
          } else {
            // Fallback if no schema properties
            actualToolArgs = JSON.parse(JSON.stringify(routedToolCall.arguments || {}));
          }

          // Category-to-sources mapping for both prompt and post-processing
          const defaultCategorySources: Record<string, string[]> = {
            business: ["bloomberg", "business-insider", "financial-post", "fortune", "the-wall-street-journal", "cnbc", "forbes", "axios"],
            entertainment: ["entertainment-weekly", "buzzfeed", "the-lad-bible", "mashable", "mtv-news", "the-verge", "variety", "hollywood-reporter"],
            general: ["bbc-news", "cnn", "reuters", "the-new-york-times", "the-washington-post", "google-news", "abc-news", "cbs-news", "nbc-news", "usa-today", "al-jazeera-english", "the-guardian-uk", "independent", "associated-press"],
            health: ["medical-news-today", "national-geographic", "time", "stat-news", "who-int"],
            science: ["national-geographic", "new-scientist", "wired", "nature", "discover-magazine", "scientific-american"],
            sports: ["espn", "bbc-sport", "marca", "four-four-two", "nfl-news", "nhl-news", "fox-sports", "bleacher-report", "talksport"],
            technology: ["techcrunch", "wired", "engadget", "ars-technica", "the-verge", "techradar", "mit-technology-review"]
          };
          const availableSources = [
            "bbc-news", "cnn", "reuters", "the-new-york-times", "the-washington-post", "google-news", "abc-news", "cbs-news", "nbc-news", "usa-today", "al-jazeera-english", "the-guardian-uk", "independent", "bloomberg", "business-insider", "financial-post", "fortune", "the-wall-street-journal", "cnbc", "forbes", "axios", "entertainment-weekly", "buzzfeed", "the-lad-bible", "mashable", "mtv-news", "the-verge", "variety", "hollywood-reporter", "medical-news-today", "national-geographic", "time", "stat-news", "who-int", "new-scientist", "wired", "nature", "discover-magazine", "scientific-american", "espn", "bleacher-report", "fox-sports", "bbc-sport", "talksport", "four-four-two", "nfl-news", "nhl-news", "marca", "techcrunch", "engadget", "ars-technica", "techradar", "mit-technology-review", "associated-press"
          ];
          const availableCategories = ["general", "business", "entertainment", "health", "science", "sports", "technology"];

          function categorizeQuery(query?: string): string {
            if (!query) return "general";
            const q = query.toLowerCase();
            if (q.match(/\b(apple|google|microsoft|samsung|amazon|facebook|meta|ibm|intel|nvidia|amd|qualcomm|cisco|oracle|sap|salesforce|tesla|spacex|openai|alphagoog)\b/i)) return "technology";
            if (q.match(/\b(iphone|android|pixel|galaxy|windows|macos|linux|playstation|xbox|nintendo|vr|ar|ai|ml|llm|robotics|cybersecurity|cloud|aws|azure|gcp|saas|paas|iaas|devops|agile|bitcoin|ethereum|crypto|blockchain|nft|metaverse|quantum)\b/i)) return "technology";
            if (q.match(/\b(stock|market|finance|business|company|corporate|earnings|ipo|merger|acquisition|investment|economy|gdp|inflation|recession|trade|bank|bloomberg|forbes|fortune|cnbc|wsj|ft|revenue|profit|loss|share|bond|currency|nasdaq|dow|s&p|wall street|financial|entrepreneur|startup|venture capital|private equity)\b/i)) return "business";
            if (q.match(/\b(film|movie|tv|show|series|actor|actress|celebrity|entertainment|music|album|song|concert|band|singer|artist|grammy|oscar|emmy|tony|theater|theatre|hollywood|bollywood|netflix|hulu|disneyplus|hbo|amazon prime video|festival|art|dance|comedy|stand-up|podcast|youtube|tiktok|instagram|influencer)\b/i)) return "entertainment";
            if (q.match(/\b(health|medicine|medical|doctor|physician|nurse|hospital|clinic|pharma|pharmaceutical|fda|cdc|nih|who|disease|virus|covid|pandemic|vaccine|cancer|diabetes|heart|mental health|wellness|nutrition|fitness|exercise|diet|therapy|psychology|research|study|clinical trial|epidemic|outbreak|public health)\b/i)) return "health";
            if (q.match(/\b(science|research|study|experiment|discovery|space|nasa|esa|astronomy|astrophysics|physics|chemistry|biology|genetics|evolution|environment|climate change|ecology|geology|oceanography|archaeology|paleontology|scientist|laboratory|nature|innovation|nobel prize|quantum computing|biotechnology|nanotechnology)\b/i)) return "science";
            if (q.match(/\b(sports|football|nfl|soccer|mls|premier league|la liga|serie a|bundesliga|champions league|fifa|world cup|basketball|nba|wnba|baseball|mlb|hockey|nhl|olympics|tennis|golf|cricket|rugby|formula 1|nascar|esports|gaming|athlete|team|player|coach|match|game|tournament|championship|league|score|mvp|record)\b/i)) return "sports";
            return "general";
          }

          let userQuery = (typeof actualToolArgs?.query === 'string' && actualToolArgs.query.trim())
            ? actualToolArgs.query.trim()
            : (userInputForFallback || "");

          let llmExtraction: { keywords: string; sources: string; category: string } | null = null;
          const cleanUserQueryForExtraction = (userInputForFallback || "").replace(/^use\s+newstool\s*/i, '').trim();
          logger.info(`[NewsAggregatorTool] LLM extraction input: "${cleanUserQueryForExtraction}"`);

          if (cleanUserQueryForExtraction && cleanUserQueryForExtraction.trim().length > 0) {
            const sportsSources = defaultCategorySources.sports;
            const categorySourceMapping = `
Category-to-Sources Mapping:
- sports: ${defaultCategorySources.sports.join(", ")}
- technology: ${defaultCategorySources.technology.join(", ")}
- business: ${defaultCategorySources.business.join(", ")}
- entertainment: ${defaultCategorySources.entertainment.join(", ")}
- health: ${defaultCategorySources.health.join(", ")}
- science: ${defaultCategorySources.science.join(", ")}
- general: ${defaultCategorySources.general.join(", ")}
`;
            const extractionPrompt =
`You are an expert news search query formulator.
Given the user query: "${cleanUserQueryForExtraction.replace(/"/g, '\"')}"

${categorySourceMapping}

Your tasks are, in order:
1. Determine the single best news category from this list: ${availableCategories.join(", ")}.
2. Based on the determined category AND the user query, extract the most essential search keywords. Be concise. If the query is conversational (e.g., "tell me news about X"), extract only "X".
3. Critically, based *primarily on the category you selected in step 1*, identify up to 3-5 most relevant news sources from the mapping above. For example, if the category is 'sports', you MUST pick only from the sports sources listed. Do NOT pick general sources like 'bbc-news', 'cnn', or 'reuters' for sports unless the query is about general sports news, not a specific athlete, team, or event.
   If unsure or if the query is very generic despite a category, you can use broad sources like 'google-news', or leave sources empty.

Respond in STRICT JSON format:
{
  "keywords": "string (concise search keywords, e.g., 'Apple iPhone 15' or 'global warming impact')",
  "sources": "string (comma-separated source IDs, e.g., 'espn,marca' or 'techcrunch,the-verge' or '')",
  "category": "string (one of: ${availableCategories.join(", ")})"
}

Focus on accuracy and relevance for news aggregation. Ensure keywords are clean and sources strongly match the determined category.
Example 1 Query: "use newstool what's the latest on the Tesla Cybertruck"
Example 1 JSON:
{
  "keywords": "Tesla Cybertruck",
  "sources": "techcrunch,the-verge,ars-technica",
  "category": "technology"
}
Example 2 Query: "latest news about Lionel Messi transfer rumors"
Example 2 JSON:
{
  "keywords": "Lionel Messi transfer",
  "sources": "espn,marca,bbc-sport",
  "category": "sports"
}`;
            try {
              const llmResult = await generateStructuredJson<{ keywords: string; sources: string; category: string } | { error: string }>(
                extractionPrompt,
                cleanUserQueryForExtraction,
                {
                  type: "object",
                  properties: {
                    keywords: { type: "string" },
                    sources: { type: "string" },
                    category: { type: "string", enum: [...availableCategories, ""] }
                  },
                  required: ["keywords", "sources", "category"],
                  additionalProperties: false
                },
                "minato_news_query_extraction_v1",
                [],
                (appConfig.openai.extractionModel || "gpt-4o-mini-2024-07-18"),
                userId
              );
              logger.info(`[NewsAggregatorTool] LLM extraction result: ${JSON.stringify(llmResult)}`);
              if (
                llmResult &&
                typeof llmResult === "object" &&
                !llmResult.hasOwnProperty("error") &&
                (llmResult as { keywords: string }).keywords &&
                typeof (llmResult as { keywords: string }).keywords === "string" &&
                (llmResult as { keywords: string }).keywords.trim() !== ""
              ) {
                llmExtraction = llmResult as { keywords: string; sources: string; category: string };
              }
            } catch (e) {
              logger.warn(`${logPrefix} LLM news query extraction failed: ${((e as any).message) || e}`);
            }
          }

          if (llmExtraction) {
            let cleanedKeywords = llmExtraction.keywords.trim();
            if (cleanedKeywords.split(" ").length > 10) {
              logger.warn(`[NewsAggregatorTool] LLM extracted long keywords: "${cleanedKeywords}". Using as is, but ideally prompt should make it more concise.`);
            }
            actualToolArgs.query = cleanedKeywords;
            if (llmExtraction.sources && typeof llmExtraction.sources === 'string' && llmExtraction.sources.trim()) {
              actualToolArgs.sources = llmExtraction.sources.trim();
            }
            if (llmExtraction.category && typeof llmExtraction.category === 'string' && llmExtraction.category.trim() && availableCategories.includes(llmExtraction.category.trim())) {
              actualToolArgs.category = llmExtraction.category.trim();
            } else if (!actualToolArgs.category && actualToolArgs.query) {
              actualToolArgs.category = categorizeQuery(actualToolArgs.query);
            }
            // --- Post-processing: If category is set and sources do not include any mapped sources, override ---
            const cat = actualToolArgs.category && defaultCategorySources[actualToolArgs.category] ? actualToolArgs.category : null;
            if (
              cat &&
              (!actualToolArgs.sources || !actualToolArgs.sources.split(',').some((src: string) => defaultCategorySources[cat].includes(src.trim())))
            ) {
              actualToolArgs.sources = defaultCategorySources[cat].join(',');
              logger.warn(`[NewsAggregatorTool] Overriding sources to category-specific: "${actualToolArgs.sources}" for category '${cat}'.`);
            }
            // Always normalize sources string after any LLM or fallback assignment
            if (actualToolArgs.sources && typeof actualToolArgs.sources === 'string') {
              actualToolArgs.sources = actualToolArgs.sources
                .split(',')
                .map((s: string) => s.trim())
                .filter(Boolean)
                .join(',');
            }
          }

          // Fallback if LLM extraction didn't populate args or if query is still missing/problematic
          if (!actualToolArgs.query || typeof actualToolArgs.query !== 'string' || actualToolArgs.query.trim() === "" || actualToolArgs.query.toLowerCase().startsWith("use newstool")) {
            if (userInputForFallback && typeof userInputForFallback === 'string' && userInputForFallback.trim()) {
              let cleanedFallbackQuery = userInputForFallback.replace(/^use\s+newstool\s*/i, '').trim();
              cleanedFallbackQuery = cleanedFallbackQuery.replace(/^(latest news about|news about|get news on|find news about|tell me about news for)\s+/i, '').trim();
              actualToolArgs.query = cleanedFallbackQuery || "general news";
              logger.warn(`[NewsAggregatorTool] Fallback to cleaned user input for query: "${actualToolArgs.query}"`);
            } else {
              actualToolArgs.query = "latest news";
            }
          }

          if (!actualToolArgs.category || !availableCategories.includes(actualToolArgs.category)) {
            actualToolArgs.category = categorizeQuery(actualToolArgs.query);
            logger.warn(`[NewsAggregatorTool] Fallback to categorized query for category: "${actualToolArgs.category}" based on query "${actualToolArgs.query}"`);
          }

          if ((!actualToolArgs.sources || actualToolArgs.sources.trim() === "" || actualToolArgs.sources.trim().toLowerCase() === "all") && actualToolArgs.query) {
            const defaultCategorySources = {
              business: ["bloomberg", "business-insider", "financial-post", "fortune", "the-wall-street-journal", "cnbc", "forbes", "axios"],
              entertainment: ["entertainment-weekly", "buzzfeed", "the-lad-bible", "mashable", "mtv-news", "the-verge", "variety", "hollywood-reporter"],
              general: ["bbc-news", "cnn", "reuters", "the-new-york-times", "the-washington-post", "google-news", "abc-news", "cbs-news", "nbc-news", "usa-today", "al-jazeera-english", "the-guardian-uk", "independent", "associated-press"],
              health: ["medical-news-today", "national-geographic", "time", "stat-news", "who-int"],
              science: ["national-geographic", "new-scientist", "wired", "nature", "discover-magazine", "scientific-american"],
              sports: ["espn", "bleacher-report", "fox-sports", "bbc-sport", "talksport", "four-four-two", "nfl-news", "nhl-news", "marca"],
              technology: ["techcrunch", "wired", "engadget", "ars-technica", "the-verge", "techradar", "mit-technology-review"]
            };
            const categoryForSources = actualToolArgs.category && availableCategories.includes(actualToolArgs.category) ? actualToolArgs.category : categorizeQuery(actualToolArgs.query);
            actualToolArgs.sources = defaultCategorySources[categoryForSources as keyof typeof defaultCategorySources].join(",");
            logger.warn(`[NewsAggregatorTool] Fallback to default sources for category '${categoryForSources}': "${actualToolArgs.sources}"`);
          }

          // Log the final NewsAggregatorTool arguments for debugging
          logger.info(`[NewsAggregatorTool] Final actualToolArgs: ${JSON.stringify(actualToolArgs)}`);
        }
        // --- END: NewsAggregatorTool-specific fallback for required arguments ---

        // --- BEGIN: WebSearchTool-specific fallback for required arguments ---
        if (canonicalToolName === "WebSearchTool") {
          // Filter arguments to only include properties defined in WebSearchTool's schema FIRST
          if (tool.argsSchema && tool.argsSchema.properties) {
            const validProps = Object.keys(tool.argsSchema.properties);
            const filteredOriginalArgs: Record<string, any> = {};
            
            // Only include properties that are defined in WebSearchTool's schema
            for (const prop of validProps) {
              if (prop in routedToolCall.arguments) {
                filteredOriginalArgs[prop] = routedToolCall.arguments[prop];
              }
            }
            
            // Use filtered arguments as the base
            actualToolArgs = JSON.parse(JSON.stringify(filteredOriginalArgs));
          } else {
            // Fallback if no schema properties
            actualToolArgs = JSON.parse(JSON.stringify(routedToolCall.arguments || {}));
          }
          
          // Apply stripSystemPrefixes to any existing query first
          if (actualToolArgs.query && typeof actualToolArgs.query === 'string') {
            actualToolArgs.query = stripSystemPrefixes(actualToolArgs.query);
          }
          
          // If any required parameters are missing, provide default values
          if (!actualToolArgs.mode || !actualToolArgs.query || actualToolArgs.location === undefined || 
              actualToolArgs.language === undefined || actualToolArgs.minPrice === undefined || 
              actualToolArgs.maxPrice === undefined || actualToolArgs.color === undefined || 
              actualToolArgs.brand === undefined) {
            
            logger.warn(`${logPrefix} Tool 'WebSearchTool' called with missing required parameters. Using cleaned fallback user input: "${userInputForFallback?.substring(0, 50)}..."`);
            
            // Save the original user input via apiContext instead of in the args
            if (!apiContext.webSearchContext) apiContext.webSearchContext = {};
            apiContext.webSearchContext.userInput = userInputForFallback;
            apiContext.webSearchContext.userName = await this.getUserFirstName(userId);
            
            // Set query if missing
            if (!actualToolArgs.query && userInputForFallback) {
              const cleanedInput = userInputForFallback
                .replace(/^use\s+web(\s*search)?\s*(tool)?\s*to\s*/i, '')
                .replace(/^(hey|hi|hello|ok|okay)\s+(minato|there)\s*/i, '')
                .replace(/^can\s+you\s+/i, '')
                .replace(/^please\s+/i, '')
                .trim();
                
              // Strip system prefixes from the cleaned input
              actualToolArgs.query = stripSystemPrefixes(cleanedInput);
            }
            
            // Set default mode based on query content if missing
            if (!actualToolArgs.mode) {
              let defaultMode = "fallback_search"; // Default to general search
              
              const userQuery = (actualToolArgs.query || userInputForFallback || "").toLowerCase();
              
              // Check if this looks like a TikTok search
              if (userQuery.includes("tiktok") || userQuery.includes("tik tok") || 
                  (userQuery.includes("video") && !userQuery.includes("youtube") && !userQuery.includes("recipe")) ||
                  userQuery.includes("dance") || userQuery.includes("trend") || userQuery.includes("viral") ||
                  userQuery.includes("challenge")) {
                defaultMode = "tiktok_search";
              }
              
              // Apply the default mode
              actualToolArgs.mode = defaultMode;
              logger.info(`${logPrefix} Set default mode '${defaultMode}' for WebSearchTool based on query content`);
            }
            
            // Set other required parameters with null values if they're missing
            if (actualToolArgs.location === undefined) actualToolArgs.location = null;
            if (actualToolArgs.language === undefined) actualToolArgs.language = null;
            
            // Try to extract location from query if possible
            const locationRegex = /\b(?:in|at|from|for)\s+([A-Za-z\s]+(?:,\s*[A-Za-z\s]+)?)\b/i;
            const userQuery = actualToolArgs.query || "";
            const locationMatch = userQuery.match(locationRegex);
            if (locationMatch && locationMatch[1]) {
              actualToolArgs.location = locationMatch[1].trim();
            }
            
            logger.info(`${logPrefix} WebSearchTool parameters after fallback: ${JSON.stringify(actualToolArgs)}`);
          }
        }
        // --- END: WebSearchTool-specific fallback for required arguments ---

        // --- BEGIN: SportsInfoTool-specific fallback for required arguments ---
        if (canonicalToolName === "SportsInfoTool") {
          // If either teamName or queryType is missing, try to infer using LLM or fallback
          const missingTeamName = !actualToolArgs.teamName || typeof actualToolArgs.teamName !== 'string' || actualToolArgs.teamName.trim() === "";
          const missingQueryType = !actualToolArgs.queryType || typeof actualToolArgs.queryType !== 'string' || actualToolArgs.queryType.trim() === "";
          if (missingTeamName || missingQueryType) {
            // --- BEGIN: ADVANCED CLEANING FOR SPORTS QUERIES ---
            let cleanedUserInputForFallback = userInputForFallback;
            if (typeof cleanedUserInputForFallback === 'string') {
              // Remove leading Minato references
              cleanedUserInputForFallback = cleanedUserInputForFallback.replace(/^(hey |ok |hi |hello )?minato[,:]?\s*/i, "");
              // Remove generic prefixes
              cleanedUserInputForFallback = cleanedUserInputForFallback.replace(/^(provides|provide|get|show|give|find|tell|who|what) (me )?(information|info|details)? ?(about|on)? ?/i, "");
              cleanedUserInputForFallback = cleanedUserInputForFallback.replace(/^(information|info|details) about /i, "");
              cleanedUserInputForFallback = cleanedUserInputForFallback.replace(/^about /i, "");
              // Remove trailing tool/implementation hints
              cleanedUserInputForFallback = cleanedUserInputForFallback.replace(/(using|with|via) (the)?sports(db)?( api|tool)?(\.|,)?\s*$/i, "");
              cleanedUserInputForFallback = cleanedUserInputForFallback.replace(/(using|with|via) [^.,;!?]+(\.|,)?\s*$/i, "");
              // Remove trailing polite words
              cleanedUserInputForFallback = cleanedUserInputForFallback.replace(/\b(please|thanks|thank you)[.!?, ]*$/i, "");
              cleanedUserInputForFallback = cleanedUserInputForFallback.trim();
            }
            // --- END: ADVANCED CLEANING ---
            // Try LLM extraction first
            try {
              const extractionPrompt = `You are an expert sports information assistant. Given the user query: "${cleanedUserInputForFallback.replace(/"/g, '\"')}"

Your tasks are:
1. Ignore any references to the tool, API, or the assistant's name (e.g., 'using TheSportsDB', 'with SportsInfoTool', 'minato', etc.).
2. Extract the most likely sports team name (e.g., "Arsenal", "Los Angeles Lakers", "Manchester United"). If the query is about a match between two teams (e.g., 'arsenal vs utd'), extract both team names as a string joined by ' vs ' (e.g., 'Arsenal vs Manchester United').
3. Determine the type of information requested: one of "next_game", "last_game", or "team_info". Use "team_info" if the user just wants general info, "next_game" for the next scheduled match, or "last_game" for the most recent result or score. If the query is about a match between two teams, prefer "last_game" or "next_game" as appropriate.

Respond in STRICT JSON format:
{
  "teamName": "string (the team name, or 'TeamA vs TeamB' if a match is referenced)",
  "queryType": "string (one of: 'next_game', 'last_game', 'team_info')"
}

Examples:
Query: "When is Arsenal's next match?"
JSON: { "teamName": "Arsenal", "queryType": "next_game" }
Query: "Tell me about the Lakers."
JSON: { "teamName": "Los Angeles Lakers", "queryType": "team_info" }
Query: "What was the last result for Manchester United?"
JSON: { "teamName": "Manchester United", "queryType": "last_game" }
Query: "minato giving the last score of arsenal vs utd"
JSON: { "teamName": "Arsenal vs Manchester United", "queryType": "last_game" }
Query: "give the next game of madrid"
JSON: { "teamName": "Real Madrid", "queryType": "next_game" }
`;
              const llmResult = await generateStructuredJson<{ teamName: string; queryType: string } | { error: string }>(
                extractionPrompt,
                cleanedUserInputForFallback,
                {
                  type: "object",
                  properties: {
                    teamName: { type: "string" },
                    queryType: { type: "string", enum: ["next_game", "last_game", "team_info"] }
                  },
                  required: ["teamName", "queryType"],
                  additionalProperties: false
                },
                "minato_sports_query_extraction_v1",
                [],
                (appConfig.openai.extractionModel || "gpt-4o-mini-2024-07-18"),
                userId
              );
              logger.info(`[SportsInfoTool] LLM extraction result: ${JSON.stringify(llmResult)}`);
              if (
                llmResult &&
                typeof llmResult === "object" &&
                !llmResult.hasOwnProperty("error") &&
                (llmResult as { teamName: string }).teamName &&
                typeof (llmResult as { teamName: string }).teamName === "string" &&
                (llmResult as { teamName: string }).teamName.trim() !== "" &&
                (llmResult as { queryType: string }).queryType &&
                typeof (llmResult as { queryType: string }).queryType === "string"
              ) {
                actualToolArgs.teamName = (llmResult as { teamName: string }).teamName.trim();
                actualToolArgs.queryType = (llmResult as { queryType: string }).queryType.trim();
              }
            } catch (e) {
              logger.warn(`${logPrefix} LLM sports query extraction failed: ${((e as any).message) || e}`);
            }
            // Fallback: If LLM failed, try regex or simple heuristics
            if (!actualToolArgs.teamName && cleanedUserInputForFallback) {
              // Try to extract a 'vs' match
              const vsMatch = cleanedUserInputForFallback.match(/([A-Za-z\s]+)\s+vs\.?\s*([A-Za-z\s]+)/i);
              if (vsMatch) {
                actualToolArgs.teamName = `${vsMatch[1].trim()} vs ${vsMatch[2].trim()}`;
              } else {
                // Try to extract a team name by looking for capitalized words or known team patterns
                const teamMatch = cleanedUserInputForFallback.match(/about ([A-Z][a-zA-Z\s]+)|for ([A-Z][a-zA-Z\s]+)|of ([A-Z][a-zA-Z\s]+)|([A-Z][a-zA-Z\s]+)'s|([A-Z][a-zA-Z\s]+)\s+(next|last|game|match|result|info)/i);
                if (teamMatch) {
                  actualToolArgs.teamName = (teamMatch[1] || teamMatch[2] || teamMatch[3] || teamMatch[4] || teamMatch[5] || "").trim();
                } else {
                  // As a last resort, use the whole input if it's short
                  if (cleanedUserInputForFallback.length < 40) actualToolArgs.teamName = cleanedUserInputForFallback.trim();
                }
              }
            }
            if (!actualToolArgs.queryType && cleanedUserInputForFallback) {
              if (/next/i.test(cleanedUserInputForFallback)) actualToolArgs.queryType = "next_game";
              else if (/last|previous|result|score/i.test(cleanedUserInputForFallback)) actualToolArgs.queryType = "last_game";
              else actualToolArgs.queryType = "team_info";
            }
          }
        }
        // --- END: SportsInfoTool-specific fallback for required arguments ---
        // --- BEGIN: RedditTool-specific fallback for required arguments ---
        if (canonicalToolName === "RedditTool") {
          // If subreddit is missing, try to infer using LLM or fallback
          const missingSubreddit = !actualToolArgs.subreddit || typeof actualToolArgs.subreddit !== 'string' || actualToolArgs.subreddit.trim() === "";
          if (missingSubreddit) {
            // --- BEGIN: ADVANCED CLEANING FOR REDDIT QUERIES ---
            let cleanedUserInputForReddit = userInputForFallback;
            if (typeof cleanedUserInputForReddit === 'string') {
              // Remove leading Minato references
              cleanedUserInputForReddit = cleanedUserInputForReddit.replace(/^(hey |ok |hi |hello )?minato[,:]?\s*/i, "");
              // Remove generic prefixes
              cleanedUserInputForReddit = cleanedUserInputForReddit.replace(/^(using|use|show|find|get|search|tell|give) (me )?(about|for|the|a|an)? ?/i, "");
              cleanedUserInputForReddit = cleanedUserInputForReddit.replace(/^(reddit|reddit tool|reddit api|reddit search|reddit posts|posts|subreddit|subreddits) (about|for|on)? ?/i, "");
              cleanedUserInputForReddit = cleanedUserInputForReddit.replace(/^about /i, "");
              // Remove trailing tool/implementation hints
              cleanedUserInputForReddit = cleanedUserInputForReddit.replace(/(using|with|via) (the)?reddit(api|tool)?( tool)?(\.|,)?\s*$/i, "");
              cleanedUserInputForReddit = cleanedUserInputForReddit.replace(/(using|with|via) [^.,;!?]+(\.|,)?\s*$/i, "");
              // Remove trailing polite words
              cleanedUserInputForReddit = cleanedUserInputForReddit.replace(/\b(please|thanks|thank you)[.!?, ]*$/i, "");
              cleanedUserInputForReddit = cleanedUserInputForReddit.trim();
            }
            // --- END: ADVANCED CLEANING ---
            // Try LLM extraction first
            try {
              const extractionPrompt = `You are an expert Reddit assistant. Given the user query: "${cleanedUserInputForReddit.replace(/"/g, '\"')}"

Your tasks are:
1. Ignore any references to the tool, API, or the assistant's name (e.g., 'using RedditTool', 'with Reddit API', 'minato', etc.).
2. Extract the most likely subreddit (e.g., 'technology', 'gadgets', 'ai', 'all', etc.). If the query is general or doesn't specify a subreddit, use 'all'.
3. If the user query is a search (e.g., 'find ai gadget'), extract the search keywords as 'query'.
4. Determine the filter: one of 'hot', 'new', 'top', or 'rising'. If not specified, use 'hot'.
5. If the filter is 'top', extract the time period if present (e.g., 'day', 'week', etc.), else use 'day'.
6. Set limit to 5 unless the user specifies otherwise.

Respond in STRICT JSON format:
{
  "subreddit": "string (the subreddit, e.g., 'technology', 'all', etc.)",
  "filter": "string (one of: 'hot', 'new', 'top', 'rising')",
  "time": "string|null (one of: 'hour', 'day', 'week', 'month', 'year', 'all', or null)",
  "limit": "number (1-10)"
}

Examples:
Query: "using reddit tool find ai gadget"
JSON: { "subreddit": "all", "filter": "hot", "time": null, "limit": 5 }
Query: "show me top posts from technology this week"
JSON: { "subreddit": "technology", "filter": "top", "time": "week", "limit": 5 }
Query: "find memes on reddit"
JSON: { "subreddit": "memes", "filter": "hot", "time": null, "limit": 5 }
`;
              const llmResult = await generateStructuredJson<{ subreddit: string; filter: string; time: string|null; limit: number } | { error: string }>(
                extractionPrompt,
                cleanedUserInputForReddit,
                {
                  type: "object",
                  properties: {
                    subreddit: { type: "string" },
                    filter: { type: "string", enum: ["hot", "new", "top", "rising"] },
                    time: { type: ["string", "null"], enum: ["hour", "day", "week", "month", "year", "all", null] },
                    limit: { type: "number", minimum: 1, maximum: 10 }
                  },
                  required: ["subreddit", "filter", "time", "limit"],
                  additionalProperties: false
                },
                "minato_reddit_query_extraction_v1",
                [],
                (appConfig.openai.extractionModel || "gpt-4o-mini-2024-07-18"),
                userId
              );
              logger.info(`[RedditTool] LLM extraction result: ${JSON.stringify(llmResult)}`);
              if (
                llmResult &&
                typeof llmResult === "object" &&
                !llmResult.hasOwnProperty("error") &&
                (llmResult as { subreddit: string }).subreddit &&
                typeof (llmResult as { subreddit: string }).subreddit === "string" &&
                (llmResult as { subreddit: string }).subreddit.trim() !== "" &&
                (llmResult as { filter: string }).filter &&
                typeof (llmResult as { filter: string }).filter === "string"
              ) {
                actualToolArgs.subreddit = (llmResult as { subreddit: string }).subreddit.trim();
                actualToolArgs.filter = (llmResult as { filter: string }).filter.trim();
                actualToolArgs.time = (llmResult as { time: string|null }).time;
                actualToolArgs.limit = (llmResult as { limit: number }).limit;
              }
            } catch (e) {
              logger.warn(`${logPrefix} LLM reddit query extraction failed: ${((e as any).message) || e}`);
            }
            // Fallback: If LLM failed, try regex or simple heuristics
            if (!actualToolArgs.subreddit && cleanedUserInputForReddit) {
              // Try to extract a subreddit by looking for r/subreddit or common subreddit names
              const subredditMatch = cleanedUserInputForReddit.match(/r\/(\w{3,21})/i);
              if (subredditMatch) {
                actualToolArgs.subreddit = subredditMatch[1];
              } else if (/meme/i.test(cleanedUserInputForReddit)) {
                actualToolArgs.subreddit = "memes";
              } else if (/ai|gadget|tech|robot|machine/i.test(cleanedUserInputForReddit)) {
                actualToolArgs.subreddit = "technology";
              } else {
                actualToolArgs.subreddit = "all";
              }
              // Fallback filter
              if (!actualToolArgs.filter) {
                if (/new/i.test(cleanedUserInputForReddit)) actualToolArgs.filter = "new";
                else if (/top/i.test(cleanedUserInputForReddit)) actualToolArgs.filter = "top";
                else if (/rising/i.test(cleanedUserInputForReddit)) actualToolArgs.filter = "rising";
                else actualToolArgs.filter = "hot";
              }
              // Fallback time
              if (!actualToolArgs.time && actualToolArgs.filter === "top") {
                if (/week/i.test(cleanedUserInputForReddit)) actualToolArgs.time = "week";
                else if (/month/i.test(cleanedUserInputForReddit)) actualToolArgs.time = "month";
                else if (/year/i.test(cleanedUserInputForReddit)) actualToolArgs.time = "year";
                else if (/all time|alltime|all/i.test(cleanedUserInputForReddit)) actualToolArgs.time = "all";
                else actualToolArgs.time = "day";
              } else if (!actualToolArgs.time) {
                actualToolArgs.time = null;
              }
              // Fallback limit
              if (!actualToolArgs.limit || typeof actualToolArgs.limit !== 'number') {
                actualToolArgs.limit = 5;
              }
            }
          }
        }
        // --- END: RedditTool-specific fallback for required arguments ---
        // --- BEGIN: PexelsSearchTool-specific fallback for required arguments ---
        if (canonicalToolName === "PexelsSearchTool") {
          const missingQuery = !actualToolArgs.query || typeof actualToolArgs.query !== 'string' || actualToolArgs.query.trim() === "";
          const missingLimit = actualToolArgs.limit === undefined || actualToolArgs.limit === null || isNaN(Number(actualToolArgs.limit));
          const missingOrientation = actualToolArgs.orientation === undefined;
          const missingSize = actualToolArgs.size === undefined;
          let cleanedUserInputForPexels = userInputForFallback;
          if (typeof cleanedUserInputForPexels === 'string') {
            cleanedUserInputForPexels = cleanedUserInputForPexels.replace(/^(hey |ok |hi |hello )?minato[,:]?\s*/i, "");
            cleanedUserInputForPexels = cleanedUserInputForPexels.replace(/^(use|using|show|find|get|search|tell|give|provide|suggest|recommend) (me )?(about|for|the|a|an)? ?/i, "");
            cleanedUserInputForPexels = cleanedUserInputForPexels.replace(/^(pexels|pexel|pexels tool|pexel tool|pexels api|pexel api|pexels search|pexel search|image|images|photo|photos|picture|pictures|media) (about|for|on)? ?/i, "");
            cleanedUserInputForPexels = cleanedUserInputForPexels.replace(/^about /i, "");
            cleanedUserInputForPexels = cleanedUserInputForPexels.replace(/(using|with|via) (the)?pexels(api|tool)?( tool)?(\.|,)?\s*$/i, "");
            cleanedUserInputForPexels = cleanedUserInputForPexels.replace(/(using|with|via) [^.,;!?]+(\.|,)?\s*$/i, "");
            cleanedUserInputForPexels = cleanedUserInputForPexels.replace(/\b(please|thanks|thank you)[.!?, ]*$/i, "");
            cleanedUserInputForPexels = cleanedUserInputForPexels.trim();
          }
          try {
            const extractionPrompt = `You are an expert image search assistant. Given the user query: "${cleanedUserInputForPexels.replace(/"/g, '\"')}"
        Your tasks are:
        1. Ignore any references to the tool, API, or the assistant's name (e.g., 'using PexelsTool', 'with Pexels API', 'minato', etc.).
        2. Extract the most likely search query for images (e.g., 'nature', 'cat', 'city skyline').
        3. If the user specifies a number of images, extract it as 'limit' (between 1 and 5). Otherwise, use 3.
        4. If the user specifies orientation (landscape, portrait, square), extract it. Otherwise, use null.
        5. If the user specifies size (large, medium, small), extract it. Otherwise, use null.
        Respond in STRICT JSON format:
        {
          "query": "string (the concise search query, required)",
          "limit": "number (1-5, default 3)",
          "orientation": "string|null (landscape, portrait, square, or null)",
          "size": "string|null (large, medium, small, or null)"
        }
        Examples:
        Query: "find 2 landscape images of cats on pexels"
        JSON: { "query": "cats", "limit": 2, "orientation": "landscape", "size": null }
        Query: "pexels tool show me a small portrait photo of a city skyline"
        JSON: { "query": "city skyline", "limit": 3, "orientation": "portrait", "size": "small" }
        Query: "get nature images"
        JSON: { "query": "nature", "limit": 3, "orientation": null, "size": null }
        `;
            const llmResult = await generateStructuredJson<{ query: string; limit: number; orientation: string|null; size: string|null } | { error: string }>(
              extractionPrompt,
              cleanedUserInputForPexels,
              {
                type: "object",
                properties: {
                  query: { type: "string" },
                  limit: { type: "number", minimum: 1, maximum: 5 },
                  orientation: { type: ["string", "null"], enum: ["landscape", "portrait", "square", null] },
                  size: { type: ["string", "null"], enum: ["large", "medium", "small", null] }
                },
                required: ["query", "limit", "orientation", "size"],
                additionalProperties: false
              },
              "minato_pexels_query_extraction_v1",
              [],
              (appConfig.openai.extractionModel || "gpt-4o-mini-2024-07-18"),
              userId
            );
            logger.info(`[PexelsSearchTool] LLM extraction result: ${JSON.stringify(llmResult)}`);
            if (
              llmResult &&
              typeof llmResult === "object" &&
              !llmResult.hasOwnProperty("error") &&
              (typeof (llmResult as { query: string }).query === "string") &&
              (typeof (llmResult as { limit: number }).limit === "number")
            ) {
              actualToolArgs.query = (llmResult as { query: string }).query.trim();
              actualToolArgs.limit = (llmResult as { limit: number }).limit;
              actualToolArgs.orientation = (llmResult as { orientation: string|null }).orientation;
              actualToolArgs.size = (llmResult as { size: string|null }).size;
            }
          } catch (e) {
            logger.warn(`${logPrefix} LLM pexels query extraction failed: ${((e as any).message) || e}`);
          }
          if ((actualToolArgs.query === undefined || actualToolArgs.query === null) && cleanedUserInputForPexels) {
            const limitMatch = cleanedUserInputForPexels.match(/(\d+)/);
            let limit = limitMatch ? Math.max(1, Math.min(parseInt(limitMatch[1], 10), 5)) : 3;
            actualToolArgs.limit = limit;
            let orientation: "landscape"|"portrait"|"square"|null = null;
            if (/landscape/i.test(cleanedUserInputForPexels)) orientation = "landscape";
            else if (/portrait/i.test(cleanedUserInputForPexels)) orientation = "portrait";
            else if (/square/i.test(cleanedUserInputForPexels)) orientation = "square";
            actualToolArgs.orientation = orientation;
            let size: "large"|"medium"|"small"|null = null;
            if (/large/i.test(cleanedUserInputForPexels)) size = "large";
            else if (/medium/i.test(cleanedUserInputForPexels)) size = "medium";
            else if (/small/i.test(cleanedUserInputForPexels)) size = "small";
            actualToolArgs.size = size;
            let query = cleanedUserInputForPexels.replace(/\b(\d+|landscape|portrait|square|large|medium|small)\b/gi, "").replace(/\s+/g, " ").trim();
            actualToolArgs.query = query || "nature";
          }
          if (actualToolArgs.limit === undefined || actualToolArgs.limit === null || isNaN(Number(actualToolArgs.limit))) actualToolArgs.limit = 3;
          if (actualToolArgs.orientation === undefined) actualToolArgs.orientation = null;
          if (actualToolArgs.size === undefined) actualToolArgs.size = null;
        }
        // --- END: PexelsSearchTool-specific fallback for required arguments ---




        // --- BEGIN: RecipeSearchTool-specific fallback for required arguments ---
        if (canonicalToolName === "RecipeSearchTool") {
          // If query is missing or noisy, try to infer using LLM or fallback
          const missingQuery = !actualToolArgs.query || typeof actualToolArgs.query !== 'string' || actualToolArgs.query.trim() === "";
          let cleanedUserInputForRecipe = userInputForFallback;
          if (typeof cleanedUserInputForRecipe === 'string') {
            // Remove leading Minato references
            cleanedUserInputForRecipe = cleanedUserInputForRecipe.replace(/^(hey |ok |hi |hello )?minato[,:]?\s*/i, "");
            // Remove generic prefixes
            cleanedUserInputForRecipe = cleanedUserInputForRecipe.replace(/^(use|using|show|find|get|search|tell|give|provide|suggest|recommend) (me )?(about|for|the|a|an)? ?/i, "");
            cleanedUserInputForRecipe = cleanedUserInputForRecipe.replace(/^(recipe|recipes|dish|dishes|meal|meals|food|cooking|cook|how to cook|how do i cook|how to make|how do i make) (about|for|on)? ?/i, "");
            cleanedUserInputForRecipe = cleanedUserInputForRecipe.replace(/^about /i, "");
            // Remove trailing tool/implementation hints
            cleanedUserInputForRecipe = cleanedUserInputForRecipe.replace(/(using|with|via) (the)?recipe(api|tool)?( tool)?(\.|,)?\s*$/i, "");
            cleanedUserInputForRecipe = cleanedUserInputForRecipe.replace(/(using|with|via) [^.,;!?]+(\.|,)?\s*$/i, "");
            // Remove trailing polite words
            cleanedUserInputForRecipe = cleanedUserInputForRecipe.replace(/\b(please|thanks|thank you)[.!?, ]*$/i, "");
            cleanedUserInputForRecipe = cleanedUserInputForRecipe.trim();
          }
          // Try LLM extraction first
          try {
            const extractionPrompt = `You are an expert recipe assistant. Given the user query: "${cleanedUserInputForRecipe.replace(/"/g, '\"')}"

Your tasks are:
1. Ignore any references to the tool, API, or the assistant's name (e.g., 'using RecipeTool', 'with Recipe API', 'minato', etc.).
2. If the user wants a random recipe (e.g., 'random recipe', 'give me any recipe', 'surprise me'), set "random" to true and leave "query" empty.
3. Otherwise, extract the most likely main ingredient, dish, or cuisine as a concise search query (e.g., 'pasta', 'chicken curry', 'carbonara').
4. If the query is too generic (e.g., just 'recipe', 'food', 'meal'), set "random" to true and leave "query" empty.

Respond in STRICT JSON format:
{
  "query": "string (the concise search query, or empty if random)",
  "random": "boolean (true if user wants a random recipe, false otherwise)"
}

Examples:
Query: "use recipe tool to give me a random recipe"
JSON: { "query": "", "random": true }
Query: "find a great recipe of pasta"
JSON: { "query": "pasta", "random": false }
Query: "how to cook a pasta sauce"
JSON: { "query": "pasta sauce", "random": false }
Query: "suggest a meal"
JSON: { "query": "", "random": true }
`;
            const llmResult = await generateStructuredJson<{ query: string; random: boolean } | { error: string }>(
              extractionPrompt,
              cleanedUserInputForRecipe,
              {
                type: "object",
                properties: {
                  query: { type: "string" },
                  random: { type: "boolean" }
                },
                required: ["query", "random"],
                additionalProperties: false
              },
              "minato_recipe_query_extraction_v1",
              [],
              (appConfig.openai.extractionModel || "gpt-4o-mini-2024-07-18"),
              userId
            );
            logger.info(`[RecipeSearchTool] LLM extraction result: ${JSON.stringify(llmResult)}`);
            if (
              llmResult &&
              typeof llmResult === "object" &&
              !llmResult.hasOwnProperty("error") &&
              (typeof (llmResult as { query: string }).query === "string") &&
              (typeof (llmResult as { random: boolean }).random === "boolean")
            ) {
              actualToolArgs.query = (llmResult as { query: string }).query.trim();
              actualToolArgs.random = (llmResult as { random: boolean }).random;
            }
          } catch (e) {
            logger.warn(`${logPrefix} LLM recipe query extraction failed: ${((e as any).message) || e}`);
          }
          // Fallback: If LLM failed, try regex or simple heuristics
          if ((actualToolArgs.query === undefined || actualToolArgs.query === null) && cleanedUserInputForRecipe) {
            // If user asks for random
            if (/random|any|surprise/i.test(cleanedUserInputForRecipe)) {
              actualToolArgs.query = "";
              actualToolArgs.random = true;
            } else {
              // Try to extract main ingredient or dish
              const match = cleanedUserInputForRecipe.match(/([a-zA-Z ]+)/);
              if (match && match[1]) {
                actualToolArgs.query = match[1].trim();
                actualToolArgs.random = false;
              } else {
                actualToolArgs.query = "";
                actualToolArgs.random = true;
              }
            }
          }
          // If query is too generic, treat as random
          if (actualToolArgs.query && /^(recipe|recipes|meal|meals|food|dishes|dish)$/i.test(actualToolArgs.query.trim())) {
            actualToolArgs.query = "";
            actualToolArgs.random = true;
          }
          // Always ensure query is a string and random is boolean
          if (typeof actualToolArgs.query !== "string") actualToolArgs.query = "";
          if (typeof actualToolArgs.random !== "boolean") actualToolArgs.random = false;
        }
        // --- END: RecipeSearchTool-specific fallback for required arguments ---
        
        // --- BEGIN: GoogleCalendarReaderTool-specific fallback for required arguments ---
        if (canonicalToolName === "GoogleCalendarReaderTool") {
          const missingAction = !actualToolArgs.action || typeof actualToolArgs.action !== 'string';
          const missingMaxResults = actualToolArgs.maxResults === undefined || actualToolArgs.maxResults === null;
          const missingCalendarId = actualToolArgs.calendarId === undefined || actualToolArgs.calendarId === null;
          
          if (missingAction || missingMaxResults || missingCalendarId) {
            logger.warn(`${logPrefix} GoogleCalendarReaderTool missing required parameters. Adding defaults.`);
            
            // Default action
            if (missingAction) {
              actualToolArgs.action = "get_today_events";
            }
            
            // Default max results
            if (missingMaxResults) {
              actualToolArgs.maxResults = 5;
            } else {
              // Ensure it's within bounds
              actualToolArgs.maxResults = Math.max(1, Math.min(actualToolArgs.maxResults, 10));
            }
            
            // Default calendar ID
            if (missingCalendarId) {
              actualToolArgs.calendarId = "primary";
            }
            
            logger.info(`${logPrefix} GoogleCalendarReaderTool parameters after fallback: ${JSON.stringify(actualToolArgs)}`);
          }
        }
        // --- END: GoogleCalendarReaderTool-specific fallback for required arguments ---
        
        // --- BEGIN: GoogleGmailReaderTool-specific fallback for required arguments ---
        if (canonicalToolName === "GoogleGmailReaderTool") {
          const missingAction = !actualToolArgs.action || typeof actualToolArgs.action !== 'string';
          const missingMaxResults = actualToolArgs.maxResults === undefined || actualToolArgs.maxResults === null;
          const missingQuery = !actualToolArgs.query || typeof actualToolArgs.query !== 'string';
          const missingSummarizeBody = actualToolArgs.summarize_body === undefined || actualToolArgs.summarize_body === null;
          const missingSummarizeLimit = actualToolArgs.summarize_limit === undefined || actualToolArgs.summarize_limit === null;
          
          if (missingAction || missingMaxResults || missingQuery || missingSummarizeBody || missingSummarizeLimit) {
            logger.warn(`${logPrefix} GoogleGmailReaderTool missing required parameters. Adding defaults.`);
            
            // Default action
            if (missingAction) {
              actualToolArgs.action = "get_recent_emails";
            }
            
            // Default max results
            if (missingMaxResults) {
              actualToolArgs.maxResults = 5;
            } else {
              // Ensure it's within bounds
              actualToolArgs.maxResults = Math.max(1, Math.min(actualToolArgs.maxResults, 10));
            }
            
            // Default query
            if (missingQuery) {
              actualToolArgs.query = "is:unread category:primary";
            }
            
            // Default summarize_body
            if (missingSummarizeBody) {
              actualToolArgs.summarize_body = false;
            }
            
            // Default summarize_limit
            if (missingSummarizeLimit) {
              actualToolArgs.summarize_limit = 1;
            } else {
              // Ensure it's within bounds
              actualToolArgs.summarize_limit = Math.max(1, Math.min(actualToolArgs.summarize_limit, 3));
            }
            
            logger.info(`${logPrefix} GoogleGmailReaderTool parameters after fallback: ${JSON.stringify(actualToolArgs)}`);
          }
        }
        // --- END: GoogleGmailReaderTool-specific fallback for required arguments ---
        
        // --- BEGIN: StripePaymentLinkTool-specific fallback for required arguments ---
        if (canonicalToolName === "StripePaymentLinkTool" as string) {
          const missingProductName = !actualToolArgs.product_name || typeof actualToolArgs.product_name !== 'string' || actualToolArgs.product_name.trim() === "";
          const missingPrice = actualToolArgs.price === undefined || actualToolArgs.price === null || isNaN(Number(actualToolArgs.price)) || Number(actualToolArgs.price) <= 0;
          
          // For StripePaymentLinkTool, we want to let the tool handle conversational flow internally
          // Only provide the raw user input for the tool to process
          if (missingProductName || missingPrice) {
            logger.warn(`${logPrefix} StripePaymentLinkTool missing required parameters. Letting tool handle conversational flow.`);
            
            // Just pass the raw user input to let the tool handle the conversation
            if (!actualToolArgs._rawUserInput && userInputForFallback) {
              actualToolArgs._rawUserInput = userInputForFallback;
            }
            
            // Set step to initial if not provided to trigger conversational flow
            if (!actualToolArgs.step) {
              actualToolArgs.step = "initial";
            }
            
            logger.info(`${logPrefix} StripePaymentLinkTool parameters after fallback: ${JSON.stringify(actualToolArgs)}`);
          }
        }
        // --- END: StripePaymentLinkTool-specific fallback for required arguments ---
        
        // --- BEGIN: HackerNewsTool-specific fallback for required arguments ---
        if (canonicalToolName === "HackerNewsTool") {
          const missingQuery = !actualToolArgs.query || typeof actualToolArgs.query !== 'string' || actualToolArgs.query.trim() === "";
          const missingFilter = !actualToolArgs.filter || typeof actualToolArgs.filter !== 'string' || actualToolArgs.filter.trim() === "";
          let cleanedUserInputForHN = userInputForFallback;
          if (typeof cleanedUserInputForHN === 'string') {
            // Remove leading Minato references
            cleanedUserInputForHN = cleanedUserInputForHN.replace(/^(hey |ok |hi |hello )?minato[,:]?\s*/i, "");
            // Remove generic prefixes
            cleanedUserInputForHN = cleanedUserInputForHN.replace(/^(show|find|get|search|fetch|give|tell|list|display|use|using|with) (me )?(about|for|the|a|an)? ?/i, "");
            // Remove tool invocation phrases
            cleanedUserInputForHN = cleanedUserInputForHN.replace(/(use|using|with|via) (the )?(hacker ?news|hn)( tool| api)?(\.|,)?\s*/gi, "");
            cleanedUserInputForHN = cleanedUserInputForHN.replace(/(hacker ?news|hn)( tool| api)?(\.|,)?\s*/gi, "");
            // Remove generic story/news words
            cleanedUserInputForHN = cleanedUserInputForHN.replace(/^(stories|posts|news|items|results) (about|for|on)? ?/i, "");
            cleanedUserInputForHN = cleanedUserInputForHN.replace(/^about /i, "");
            // Remove trailing polite words
            cleanedUserInputForHN = cleanedUserInputForHN.replace(/\b(please|thanks|thank you)[.!?, ]*$/i, "");
            cleanedUserInputForHN = cleanedUserInputForHN.trim();
          }
          if (missingQuery && missingFilter && cleanedUserInputForHN) {
            // List of generic words/phrases and assistant names
            const genericWords = [
              "fetch", "show", "get", "find", "display", "list", "stories", "posts", "news", "items", "results", "hacker news", "hn", "illuminato", "minato", "please", "thanks", "thank you"
            ];
            let cleanedLower = cleanedUserInputForHN.toLowerCase().replace(/[.,!?]/g, " ");
            for (const word of genericWords) {
              cleanedLower = cleanedLower.replace(new RegExp(`\\b${word}\\b`, "gi"), " ");
            }
            cleanedLower = cleanedLower.replace(/\s+/g, " ").trim();
            const isGeneric = cleanedLower.length < 2;
            if (isGeneric) {
              actualToolArgs.filter = "top";
              actualToolArgs.query = null;
            } else {
              actualToolArgs.query = cleanedUserInputForHN;
              actualToolArgs.filter = null;
            }
          } else {
            if (missingQuery && !missingFilter) {
              actualToolArgs.query = null;
            }
            if (!missingQuery && missingFilter) {
              actualToolArgs.filter = null;
            }
            if (!missingQuery && typeof actualToolArgs.query === 'string' && /^(top|best|new|ask|show|job)$/i.test(actualToolArgs.query.trim())) {
              actualToolArgs.filter = actualToolArgs.query.trim().toLowerCase();
              actualToolArgs.query = null;
            }
          }
          // Always set sensible defaults for time and limit if missing
          if (!("time" in actualToolArgs) || actualToolArgs.time === undefined || actualToolArgs.time === null || (typeof actualToolArgs.time === 'string' && actualToolArgs.time.trim() === "")) {
            if (actualToolArgs.filter === "top") {
              actualToolArgs.time = "day";
            } else {
              actualToolArgs.time = null;
            }
          }
          if (actualToolArgs.limit === undefined || actualToolArgs.limit === null || isNaN(Number(actualToolArgs.limit))) {
            actualToolArgs.limit = 5;
          }
        }
        // --- END: HackerNewsTool-specific fallback for required arguments ---
        // --- BEGIN: EventFinderTool-specific fallback for required arguments ---
        if (canonicalToolName === "EventFinderTool") {
          let cleanedUserInputForEvents = userInputForFallback;
          if (typeof cleanedUserInputForEvents === 'string') {
            // Standard cleaning
            cleanedUserInputForEvents = cleanedUserInputForEvents.replace(/^(hey |ok |hi |hello )?minato[,:]?\\s*/i, "");
            cleanedUserInputForEvents = cleanedUserInputForEvents
              .replace(/\\b(use|using|with|via|for|the)\\s+(event\\s*)?(finder\\s*)?(tool|api)?\\b/gi, "")
              .replace(/\\b(find|get|show|search|look for|tell me about|what|when are|any)\\s+(events?|concerts?|shows?|games?|activities?|things? to do)?\\b/gi, "")
              .replace(/\\s+/g, " ")
              .trim();
          }
          logger.info(`[EventFinderTool] Cleaned user input for extraction: "${cleanedUserInputForEvents}"`);

          // Try LLM extraction for structured event parameters
          if (cleanedUserInputForEvents) {
            try {
              const extractionPrompt = `
You are an expert event query parser. Given the user query: "${cleanedUserInputForEvents.replace(/"/g, '\\"')}"
And the current date is ${new Date().toISOString().split('T')[0]}.

Your tasks are to extract the following information:
1.  **keyword**: The main subject of the event search (e.g., "concert", "Taylor Swift", "Yankees game", "music festival", "comedy show"). If no specific event type or artist is mentioned, this can be null.
2.  **city**: The city name for the event location (e.g., "London", "New York", "Paris").
3.  **countryCode**: The 2-letter ISO country code (e.g., "GB" for London, "US" for New York, "FR" for Paris). If a city is known, try to infer the country code.
4.  **postalCode**: If a postal code is mentioned (e.g., "90210").
5.  **relativeDateDescription**: A short description of a relative date query if present (e.g., "next month", "this weekend", "tomorrow", "December", "next Friday").
6.  **classificationName**: A general category if mentioned (e.g., "Music", "Sports", "Arts & Theatre", "Family").

Respond in STRICT JSON format:
{
  "keyword": "string | null",
  "city": "string | null",
  "countryCode": "string | null",
  "postalCode": "string | null",
  "relativeDateDescription": "string | null",
  "classificationName": "string | null"
}

Examples:
Query: "events in London next month"
JSON: { "keyword": null, "city": "London", "countryCode": "GB", "postalCode": null, "relativeDateDescription": "next month", "classificationName": null }

Query: "Taylor Swift concert in New York this weekend"
JSON: { "keyword": "Taylor Swift concert", "city": "New York", "countryCode": "US", "postalCode": null, "relativeDateDescription": "this weekend", "classificationName": "Music" }

Query: "baseball games in 90210 tomorrow"
JSON: { "keyword": "baseball games", "city": null, "countryCode": "US", "postalCode": "90210", "relativeDateDescription": "tomorrow", "classificationName": "Sports" }

Query: "what's on in Paris"
JSON: { "keyword": null, "city": "Paris", "countryCode": "FR", "postalCode": null, "relativeDateDescription": null, "classificationName": null }

Query: "find rock concerts" // No location or specific date
JSON: { "keyword": "rock concerts", "city": null, "countryCode": null, "postalCode": null, "relativeDateDescription": null, "classificationName": "Music" }

Query: "family events this sunday"
JSON: { "keyword": "family events", "city": null, "countryCode": null, "postalCode": null, "relativeDateDescription": "this sunday", "classificationName": "Family"}

Handle cases where information might be missing. The 'location' field in the tool arguments should be populated by 'city' or 'postalCode'.
If a city is mentioned but no country, try your best to infer countryCode (e.g. London -> GB, Paris -> FR, Berlin -> DE, Rome -> IT, Madrid -> ES, Tokyo -> JP, Sydney -> AU, Toronto -> CA).
If only a country is mentioned (e.g., "events in Canada"), set countryCode and city to null, keyword to "events".
If a specific date is mentioned (e.g., "July 4th events"), "relativeDateDescription" can be that date string.
`;
              type EventExtractionResult = {
                keyword: string | null;
                city: string | null;
                countryCode: string | null;
                postalCode: string | null;
                relativeDateDescription: string | null;
                classificationName: string | null;
              };

              const eventFinderSchemaObject = {
                type: "object" as const,
                properties: {
                  keyword: { type: ["string", "null"] as const },
                  city: { type: ["string", "null"] as const },
                  countryCode: { type: ["string", "null"] as const },
                  postalCode: { type: ["string", "null"] as const },
                  relativeDateDescription: { type: ["string", "null"] as const },
                  classificationName: { type: ["string", "null"] as const },
                },
                required: ["keyword", "city", "countryCode", "postalCode", "relativeDateDescription", "classificationName"],
                additionalProperties: false as false
              };

              const llmResult = await generateStructuredJson<EventExtractionResult | { error: string }>(
                extractionPrompt,
                cleanedUserInputForEvents, // This is the user's query for the tool.
                eventFinderSchemaObject, // Pass the schema object directly as the third argument
                "eventfinder_arg_extraction", // Use a valid format name (no spaces)
                [], // Fifth argument: history
                (appConfig.openai.extractionModel || "gpt-4o-mini-2024-07-18"), // Sixth argument: modelName
                userId // Seventh argument: userId
              );

              logger.info(`[EventFinderTool] LLM extraction result: ${JSON.stringify(llmResult)}`);

              if (llmResult && typeof llmResult === "object" && !llmResult.hasOwnProperty("error")) {
                const extracted = llmResult as EventExtractionResult;
                actualToolArgs.keyword = extracted.keyword; // Can be null
                
                // Populate location: prioritize city, then postalCode
                if (extracted.city) {
                    actualToolArgs.location = extracted.city;
                } else if (extracted.postalCode) {
                    actualToolArgs.location = extracted.postalCode;
                } else {
                    actualToolArgs.location = null; // Explicitly null if not extracted
                }

                // If location is still null, try to use user context from UserState or apiContext
                if (actualToolArgs.location === null) {
                    const userLat = userState?.latitude || apiContext?.latitude;
                    const userLon = userState?.longitude || apiContext?.longitude;
                    if (typeof userLat === 'number' && typeof userLon === 'number') {
                        actualToolArgs.location = `${userLat},${userLon}`;
                        logger.info(`[EventFinderTool] Using user context for location: ${actualToolArgs.location}`);
                    }
                }

                actualToolArgs.countryCode = extracted.countryCode; // Can be null
                actualToolArgs.classificationName = extracted.classificationName; // Can be null

                // Date parsing from relativeDateDescription
                if (extracted.relativeDateDescription) {
                  const now = new Date();
                  let startDate: Date | null = null;
                  let endDate: Date | null = null;
                  const desc = extracted.relativeDateDescription.toLowerCase();

                  // Helper function to get the next occurrence of a specific weekday
                  // dayOfWeek: 0 for Sunday, 1 for Monday, ..., 6 for Saturday
                  function getNextWeekday(date: Date, dayOfWeek: number): Date {
                      const resultDate = new Date(date.getTime());
                      const currentDay = date.getDay();
                      let daysToAdd = (dayOfWeek - currentDay + 7) % 7;
                      if (daysToAdd === 0) { // If it's the same day of week, advance to next week
                          daysToAdd = 7;
                      }
                      resultDate.setDate(date.getDate() + daysToAdd);
                      return resultDate;
                  }

                  if (desc.includes("today")) {
                    startDate = new Date(now);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(now);
                    endDate.setHours(23, 59, 59, 999);
                  } else if (desc.includes("tomorrow")) {
                    startDate = new Date(now);
                    startDate.setDate(now.getDate() + 1);
                    startDate.setHours(0, 0, 0, 0);
                    endDate = new Date(startDate);
                    endDate.setHours(23, 59, 59, 999);
                  } else if (desc.match(/next (monday|tuesday|wednesday|thursday|friday|saturday|sunday)/)) {
                      const weekdays = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"];
                      const dayMatch = desc.match(/next (monday|tuesday|wednesday|thursday|friday|saturday|sunday)/);
                      if (dayMatch && dayMatch[1]) {
                          const targetDayIndex = weekdays.indexOf(dayMatch[1]);
                          if (targetDayIndex !== -1) {
                              startDate = getNextWeekday(now, targetDayIndex);
                              startDate.setHours(0,0,0,0);
                              endDate = new Date(startDate);
                              endDate.setHours(23,59,59,999); // Event for that single day
                          }
                      }
                  } else if (desc.match(/in (\d+) day(s)?/)) {
                      const dayMatch = desc.match(/in (\d+) day(s)?/);
                      if (dayMatch && dayMatch[1]) {
                          const numDays = parseInt(dayMatch[1], 10);
                          startDate = new Date(now);
                          startDate.setDate(now.getDate() + numDays);
                          startDate.setHours(0, 0, 0, 0);
                          endDate = new Date(startDate);
                          endDate.setHours(23, 59, 59, 999);
                      }
                  } else if (desc.match(/in (\d+) week(s)?/)) {
                      const weekMatch = desc.match(/in (\d+) week(s)?/);
                      if (weekMatch && weekMatch[1]) {
                          const numWeeks = parseInt(weekMatch[1], 10);
                          startDate = new Date(now);
                          startDate.setDate(now.getDate() + numWeeks * 7);
                          startDate.setHours(0, 0, 0, 0);
                          endDate = new Date(startDate);
                          endDate.setDate(startDate.getDate() + 6); // Full week from that start date
                          endDate.setHours(23, 59, 59, 999);
                      }
                  } else if (desc.match(/in (\d+) month(s)?/)) {
                      const monthMatch = desc.match(/in (\d+) month(s)?/);
                      if (monthMatch && monthMatch[1]) {
                          const numMonths = parseInt(monthMatch[1], 10);
                          startDate = new Date(now.getFullYear(), now.getMonth() + numMonths, now.getDate());
                          startDate.setHours(0,0,0,0);
                          // For end date, go to the end of the month that startDate lands in.
                          endDate = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0);
                          endDate.setHours(23,59,59,999);
                      }
                  } else if (desc.includes("this weekend")) {
                      startDate = new Date(now);
                      const currentDay = now.getDay(); // 0 (Sun) - 6 (Sat)
                      // Adjust startDate to the Friday of the current week.
                      // If today is Sunday (0), Friday was 2 days ago.
                      // If today is Monday (1), Friday is 4 days ahead.
                      // If today is Friday (5), Friday is today.
                      if (currentDay === 0) { // Sunday
                          startDate.setDate(now.getDate() - 2); 
                      } else {
                          startDate.setDate(now.getDate() + (5 - currentDay));
                      }
                      startDate.setHours(0, 0, 0, 0);
                      endDate = new Date(startDate);
                      endDate.setDate(startDate.getDate() + 2); // Friday, Saturday, Sunday
                      endDate.setHours(23, 59, 59, 999);
                  } else if (desc.includes("next weekend")) {
                      startDate = new Date(now);
                      // Find Monday of the current week
                      const currentDay = now.getDay();
                      const daysToCurrentMonday = (currentDay === 0) ? -6 : 1 - currentDay;
                      startDate.setDate(now.getDate() + daysToCurrentMonday);
                      // Monday of next week
                      startDate.setDate(startDate.getDate() + 7);
                      // Friday of next week
                      startDate.setDate(startDate.getDate() + 4);
                      startDate.setHours(0, 0, 0, 0);
                      endDate = new Date(startDate);
                      endDate.setDate(startDate.getDate() + 2); // Friday, Saturday, Sunday
                      endDate.setHours(23, 59, 59, 999);
                  } else if (desc.includes("this week")) {
                     startDate = new Date(now);
                     startDate.setDate(now.getDate() - (now.getDay() === 0 ? 6 : now.getDay() - 1 ) ); // Go to Monday of current week
                     startDate.setHours(0,0,0,0);
                     endDate = new Date(startDate);
                     endDate.setDate(startDate.getDate() + 6); // Go to Sunday of current week
                     endDate.setHours(23,59,59,999);
                  } else if (desc.includes("next week")) {
                    startDate = new Date(now);
                    startDate.setDate(now.getDate() + (1 - now.getDay() + 7) % 7); // Days to next Monday
                     if (startDate <= now) startDate.setDate(startDate.getDate() + 7); // ensure it's truly next week
                    startDate.setHours(0,0,0,0);
                    endDate = new Date(startDate);
                    endDate.setDate(startDate.getDate() + 6); // End of next week (Sunday)
                    endDate.setHours(23,59,59,999);
                  } else if (desc.includes("next month")) {
                    startDate = new Date(now.getFullYear(), now.getMonth() + 1, 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() + 2, 0, 23, 59, 59, 999); // Last day of next month
                  } else if (desc.includes("this month")) {
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0, 23, 59, 59, 999); // Last day of current month
                  } else if (desc.includes("this year")) {
                    startDate = new Date(now.getFullYear(), 0, 1); // Jan 1st
                    endDate = new Date(now.getFullYear(), 11, 31, 23, 59, 59, 999); // Dec 31st
                  } else if (desc.includes("next year")) {
                    startDate = new Date(now.getFullYear() + 1, 0, 1); // Jan 1st of next year
                    endDate = new Date(now.getFullYear() + 1, 11, 31, 23, 59, 59, 999); // Dec 31st of next year
                  } else {
                    // Fallback for specific "Month Day" or just "Month" like "july", "december 25th"
                    const specificMonthDayMatch = desc.match(/(january|february|march|april|may|june|july|august|september|october|november|december)(?:\s+(\d{1,2})(?:st|nd|rd|th)?)?/i);
                    if (specificMonthDayMatch) {
                        const monthName = specificMonthDayMatch[1];
                        const dayOfMonthString = specificMonthDayMatch[2];
                        const monthIndex = new Date(Date.parse(monthName + " 1, 2000")).getMonth(); // Get month index

                        if (monthIndex >=0 && monthIndex <=11) {
                            let year = now.getFullYear();
                            const dayOfMonth = dayOfMonthString ? parseInt(dayOfMonthString, 10) : 1; // Default to 1st if day not specified

                            // If the month (or specific date) has passed this year, assume next year
                            const potentialTestDateForYear = new Date(year, monthIndex, dayOfMonthString ? dayOfMonth : (new Date(year, monthIndex + 1, 0).getDate()) ); // Use last day of month if day not specified, for year check
                            if (potentialTestDateForYear < now && (now.getMonth() > monthIndex || (now.getMonth() === monthIndex && now.getDate() > (dayOfMonthString ? dayOfMonth : 0 )))) {
                                year += 1;
                            }
                            
                            startDate = new Date(year, monthIndex, dayOfMonth, 0,0,0,0);
                            if (dayOfMonthString) { // Specific day was mentioned
                                endDate = new Date(year, monthIndex, dayOfMonth, 23,59,59,999);
                            } else { // Only month was mentioned, so full month
                                endDate = new Date(year, monthIndex + 1, 0, 23,59,59,999); // Last day of the specified month
                            }
                        }
                    }
                  }

                  if (startDate) actualToolArgs.startDate = startDate.toISOString();
                  if (endDate) actualToolArgs.endDate = endDate.toISOString();
                  logger.info(`[EventFinderTool] Parsed dates: startDate=${actualToolArgs.startDate}, endDate=${actualToolArgs.endDate} from "${desc}"`);
                }
              }
            } catch (e) {
              logger.warn(`${logPrefix} LLM event query extraction failed: ${((e as any).message) || e}. Proceeding with previous/default args.`);
              // Ensure core args are at least null if LLM fails badly
              actualToolArgs.keyword = actualToolArgs.keyword || null;
              actualToolArgs.location = actualToolArgs.location || null;
              actualToolArgs.countryCode = actualToolArgs.countryCode || null;
              actualToolArgs.classificationName = actualToolArgs.classificationName || null;
              actualToolArgs.startDate = actualToolArgs.startDate || null;
              actualToolArgs.endDate = actualToolArgs.endDate || null;
            }
          }
          
          // Default values for EventFinderTool if not set by LLM or previous logic
          if (actualToolArgs.radius === undefined || actualToolArgs.radius === null) {
            actualToolArgs.radius = 25;
          }
          if (!actualToolArgs.radiusUnit) {
            actualToolArgs.radiusUnit = "miles";
          }
          if (actualToolArgs.limit === undefined || actualToolArgs.limit === null) {
            actualToolArgs.limit = 5;
          }
          // For classificationName, countryCode, startDate, endDate, keyword, location: if LLM didn't provide, 
          // we let them be potentially undefined/null so the EventFinderTool's internal defaults can apply.
          // The tool itself requires these in its schema, but might have internal logic to handle their absence.
          // Or, if the tool strictly requires them, the validation step later will catch it if they are still missing.

          if (actualToolArgs.source === undefined || actualToolArgs.source === null) {
            actualToolArgs.source = "ticketmaster";
          }

          logger.info(`[EventFinderTool] Final actualToolArgs before validation: ${JSON.stringify(actualToolArgs)}`);
        } // Closing brace for if (canonicalToolName === "EventFinderTool")
        // --- END: EventFinderTool-specific fallback for required arguments ---

        // --- BEGIN: ReminderReaderTool-specific fallback for required arguments ---
        if (canonicalToolName === "ReminderReaderTool") {
          // All arguments are optional, but we can improve the experience with LLM extraction
          if (userInputForFallback && typeof userInputForFallback === 'string' && userInputForFallback.trim()) {
            // Clean the user input
            let cleanedUserInputForReminder = userInputForFallback;
            cleanedUserInputForReminder = cleanedUserInputForReminder.replace(/^(hey |ok |hi |hello )?minato[,:]?\s*/i, "");
            cleanedUserInputForReminder = cleanedUserInputForReminder.replace(/^(show|get|give|tell|list|check|read) (me )?(my |the )?(reminders?|todos?|tasks?)?\s*/i, "");
            cleanedUserInputForReminder = cleanedUserInputForReminder.replace(/^(what are|what's|whats) (my )?(reminders?|todos?|tasks?)?\s*/i, "");
            cleanedUserInputForReminder = cleanedUserInputForReminder.trim();
            
            try {
              const extractionPrompt = `You are an expert reminder query parser. Given the user query: "${cleanedUserInputForReminder.replace(/"/g, '\"')}"

Your tasks are:
1. Determine the action type: "get_pending" (default), "get_overdue", "get_today", or "get_all"
2. Extract the time range if specified (e.g., "next 3 days" → daysAhead: 3)
3. Extract the limit if specified (e.g., "show me 5 reminders" → limit: 5)

Common patterns:
- "my reminders" → action: "get_pending", daysAhead: 7
- "overdue reminders" → action: "get_overdue"
- "today's reminders" → action: "get_today"
- "reminders for next week" → action: "get_pending", daysAhead: 7
- "all my reminders" → action: "get_all", daysAhead: 30
- "next 3 reminders" → limit: 3

Respond in STRICT JSON format:
{
  "action": "get_pending | get_overdue | get_today | get_all",
  "daysAhead": "number (0-30)",
  "limit": "number (1-20)"
}`;

              const llmResult = await generateStructuredJson<{ action: string; daysAhead: number; limit: number } | { error: string }>(
                extractionPrompt,
                cleanedUserInputForReminder,
                {
                  type: "object",
                  properties: {
                    action: { type: "string", enum: ["get_pending", "get_overdue", "get_today", "get_all"] },
                    daysAhead: { type: "number", minimum: 0, maximum: 30 },
                    limit: { type: "number", minimum: 1, maximum: 20 }
                  },
                  required: ["action", "daysAhead", "limit"],
                  additionalProperties: false
                },
                "minato_reminder_reader_extraction_v1",
                [],
                (appConfig.openai.extractionModel || "gpt-4o-mini-2024-07-18"),
                userId
              );
              
              logger.info(`[ReminderReaderTool] LLM extraction result: ${JSON.stringify(llmResult)}`);
              
              if (llmResult && typeof llmResult === "object" && !llmResult.hasOwnProperty("error")) {
                actualToolArgs.action = (llmResult as { action: string }).action;
                actualToolArgs.daysAhead = (llmResult as { daysAhead: number }).daysAhead;
                actualToolArgs.limit = (llmResult as { limit: number }).limit;
              }
            } catch (e) {
              logger.warn(`${logPrefix} LLM reminder reader extraction failed: ${((e as any).message) || e}`);
            }
          }
          
          // Apply defaults if not set
          if (!actualToolArgs.action) actualToolArgs.action = "get_pending";
          if (actualToolArgs.daysAhead === undefined) actualToolArgs.daysAhead = 7;
          if (actualToolArgs.limit === undefined) actualToolArgs.limit = 10;
        }
        // --- END: ReminderReaderTool-specific fallback for required arguments ---

        // --- BEGIN: ReminderSetterTool-specific fallback for required arguments ---
        if (canonicalToolName === "ReminderSetterTool") {
          const missingContent = !actualToolArgs.content || typeof actualToolArgs.content !== 'string' || actualToolArgs.content.trim() === "";
          const missingTime = !actualToolArgs.trigger_datetime_description || typeof actualToolArgs.trigger_datetime_description !== 'string' || actualToolArgs.trigger_datetime_description.trim() === "";
          
          if ((missingContent || missingTime) && userInputForFallback && typeof userInputForFallback === 'string' && userInputForFallback.trim()) {
            // Clean the user input
            let cleanedUserInputForSetter = userInputForFallback;
            cleanedUserInputForSetter = cleanedUserInputForSetter.replace(/^(hey |ok |hi |hello )?minato[,:]?\s*/i, "");
            cleanedUserInputForSetter = cleanedUserInputForSetter.replace(/^(remind|set a reminder|create a reminder|add a reminder) (me )?(to |about |for )?\s*/i, "");
            cleanedUserInputForSetter = cleanedUserInputForSetter.trim();
            
            try {
              const extractionPrompt = `You are an expert reminder parsing assistant. Given the user request: "${cleanedUserInputForSetter.replace(/"/g, '\"')}"

Your tasks are:
1. Extract what the user wants to be reminded about (content)
2. Extract when they want to be reminded (trigger_datetime_description)
3. Determine if it's recurring (daily, weekly, monthly, yearly)
4. Categorize the reminder (task, habit, medication, appointment, goal)
5. Assign priority (low, medium, high)

Common patterns:
- "remind me to call mom tomorrow" → content: "call mom", trigger_datetime_description: "tomorrow"
- "remind me about the meeting at 3pm" → content: "meeting", trigger_datetime_description: "at 3pm"
- "remind me to take medication every morning at 8am" → content: "take medication", trigger_datetime_description: "tomorrow at 8am", recurrence: "daily"
- "exam tomorrow" → content: "exam", trigger_datetime_description: "tomorrow"
- "workout every day at 6pm" → content: "workout", trigger_datetime_description: "today at 6pm", recurrence: "daily", category: "habit"
- "doctor appointment next Monday at 2pm" → content: "doctor appointment", trigger_datetime_description: "next Monday at 2pm", category: "appointment"

Respond in STRICT JSON format:
{
  "content": "string (what to remind about)",
  "trigger_datetime_description": "string (when to remind)",
  "recurrence_rule": "daily | weekly | monthly | yearly | null",
  "category": "task | habit | medication | appointment | goal",
  "priority": "low | medium | high"
}`;

              const llmResult = await generateStructuredJson<{ 
                content: string; 
                trigger_datetime_description: string; 
                recurrence_rule: string | null;
                category: string;
                priority: string;
              } | { error: string }>(
                extractionPrompt,
                cleanedUserInputForSetter,
                {
                  type: "object",
                  properties: {
                    content: { type: "string" },
                    trigger_datetime_description: { type: "string" },
                    recurrence_rule: { type: ["string", "null"], enum: ["daily", "weekly", "monthly", "yearly", null] },
                    category: { type: "string", enum: ["task", "habit", "medication", "appointment", "goal"] },
                    priority: { type: "string", enum: ["low", "medium", "high"] }
                  },
                  required: ["content", "trigger_datetime_description", "recurrence_rule", "category", "priority"],
                  additionalProperties: false
                },
                "minato_reminder_setter_extraction_v1",
                [],
                (appConfig.openai.extractionModel || "gpt-4o-mini-2024-07-18"),
                userId
              );
              
              logger.info(`[ReminderSetterTool] LLM extraction result: ${JSON.stringify(llmResult)}`);
              
              if (llmResult && typeof llmResult === "object" && !llmResult.hasOwnProperty("error")) {
                const extracted = llmResult as { 
                  content: string; 
                  trigger_datetime_description: string; 
                  recurrence_rule: string | null;
                  category: string;
                  priority: string;
                };
                
                if (extracted.content) actualToolArgs.content = extracted.content;
                if (extracted.trigger_datetime_description) actualToolArgs.trigger_datetime_description = extracted.trigger_datetime_description;
                if (extracted.recurrence_rule) actualToolArgs.recurrence_rule = extracted.recurrence_rule;
                if (extracted.category) actualToolArgs.category = extracted.category;
                if (extracted.priority) actualToolArgs.priority = extracted.priority;
              }
            } catch (e) {
              logger.warn(`${logPrefix} LLM reminder setter extraction failed: ${((e as any).message) || e}`);
            }
            
            // Final fallback
            if (!actualToolArgs.content && cleanedUserInputForSetter) {
              // Try to split by common time indicators
              const timeIndicators = /\b(tomorrow|today|tonight|at \d|in \d|next|this|every)\b/i;
              const match = cleanedUserInputForSetter.match(timeIndicators);
              if (match) {
                const splitIndex = cleanedUserInputForSetter.indexOf(match[0]);
                if (splitIndex > 0) {
                  actualToolArgs.content = cleanedUserInputForSetter.substring(0, splitIndex).trim();
                  actualToolArgs.trigger_datetime_description = cleanedUserInputForSetter.substring(splitIndex).trim();
                }
              }
            }
          }
        }
        // --- END: ReminderSetterTool-specific fallback for required arguments ---

        // The following searchToolsRequiringQuery, YouTubeSearchTool, SportsInfoTool, RedditTool blocks should be OUTSIDE and AFTER the EventFinderTool block.

        const searchToolsRequiringQuery = [
          "YouTubeSearchTool", "NewsAggregatorTool", "HackerNewsTool", "WebSearchTool", "MemoryTool", "PexelsSearchTool", "RecipeSearchTool"
        ];

        // Improved fallback for user input
        if (
          searchToolsRequiringQuery.includes(canonicalToolName) &&
          tool.argsSchema.required?.includes("query") &&
          (!actualToolArgs.query || typeof actualToolArgs.query !== 'string' || actualToolArgs.query.trim() === "") &&
          userInputForFallback && typeof userInputForFallback === 'string' && userInputForFallback.trim()
        ) {
          // --- BEGIN: ADVANCED CLEANING FOR YOUTUBE QUERIES ---
          let cleanedUserInputForYouTube = userInputForFallback;
          if (typeof cleanedUserInputForYouTube === 'string') {
            // Remove leading Minato references
            cleanedUserInputForYouTube = cleanedUserInputForYouTube.replace(/^(hey |ok |hi |hello )?minato[,:]?\s*/i, "");
            // Remove generic prefixes
            cleanedUserInputForYouTube = cleanedUserInputForYouTube.replace(/^(show|find|get|search|play|watch|tell|give) (me )?(about|for|the|a|an)? ?/i, "");
            cleanedUserInputForYouTube = cleanedUserInputForYouTube.replace(/^(video|videos|clip|clips) (about|for|on)? ?/i, "");
            cleanedUserInputForYouTube = cleanedUserInputForYouTube.replace(/^about /i, "");
            // Remove trailing tool/implementation hints
            cleanedUserInputForYouTube = cleanedUserInputForYouTube.replace(/(using|with|via) (the)?youtube(api|searchtool)?( tool)?(\.|,)?\s*$/i, "");
            cleanedUserInputForYouTube = cleanedUserInputForYouTube.replace(/(using|with|via) [^.,;!?]+(\.|,)?\s*$/i, "");
            // Remove trailing polite words
            cleanedUserInputForYouTube = cleanedUserInputForYouTube.replace(/\b(please|thanks|thank you)[.!?, ]*$/i, "");
            cleanedUserInputForYouTube = cleanedUserInputForYouTube.trim();
          }
          // --- END: ADVANCED CLEANING ---
          logger.warn(`${logPrefix} Tool '${canonicalToolName}' called by Router without 'query'. Using cleaned fallback user input as query: "${String(cleanedUserInputForYouTube).substring(0,50)}..."`);
          actualToolArgs.query = String(cleanedUserInputForYouTube);
        }
        // --- PATCH: Ensure YouTubeSearchTool always has a valid 'limit' ---
        if (
          canonicalToolName === "YouTubeSearchTool" &&
          (actualToolArgs.limit === undefined || actualToolArgs.limit === null || isNaN(Number(actualToolArgs.limit)))
        ) {
          actualToolArgs.limit = 5;
        }
        // Add query length validation
        if (searchToolsRequiringQuery.includes(canonicalToolName) && actualToolArgs.query) {
          const maxQueryLength = 200;
          if (actualToolArgs.query.length > maxQueryLength) {
            logger.warn(`${logPrefix} Truncating long query from ${actualToolArgs.query.length} to ${maxQueryLength} chars for ${canonicalToolName}`);
            actualToolArgs.query = actualToolArgs.query.substring(0, maxQueryLength);
          }
        }

        if (canonicalToolName === "SportsInfoTool" && tool.argsSchema.required?.includes("teamName") && (!actualToolArgs.teamName || typeof actualToolArgs.teamName !== 'string' || actualToolArgs.teamName.trim() === "")) {
          if (userInputForFallback && typeof userInputForFallback === 'string' && userInputForFallback.trim()) {
            logger.warn(`${logPrefix} SportsInfoTool called by Router without 'teamName'. Tool may fail or use a default if implemented by the tool itself based on user query: "${String(userInputForFallback).substring(0,50)}..."`);
          } else {
            logger.error(`${logPrefix} SportsInfoTool requires 'teamName', but Router didn't provide it. Skipping.`);
            toolResultsSummaryParts.push(`Error: Tool '${canonicalToolName}' skipped (missing teamName).`);
            return { role: "tool" as const, tool_call_id: callId, name: canonicalToolName, content: `Error: Tool '${canonicalToolName}' could not execute (missing required 'teamName' argument).` };
          }
        }
        if (canonicalToolName === "RedditTool" && tool.argsSchema.required?.includes("subreddit") && (!actualToolArgs.subreddit || typeof actualToolArgs.subreddit !== 'string' || actualToolArgs.subreddit.trim() === "")) {
          if (userInputForFallback && typeof userInputForFallback === 'string' && userInputForFallback.trim()) {
            logger.warn(`${logPrefix} RedditTool called by Router without 'subreddit'. Tool might use a default or fail based on query: "${String(userInputForFallback).substring(0,50)}..."`);
          } else {
            logger.error(`${logPrefix} RedditTool requires 'subreddit', but Router didn't provide it. Skipping.`);
            toolResultsSummaryParts.push(`Error: Tool '${canonicalToolName}' skipped (missing subreddit).`);
            return { role: "tool" as const, tool_call_id: callId, name: canonicalToolName, content: `Error: Tool '${canonicalToolName}' could not execute (missing required 'subreddit' argument).` };
          }
        }
        if (canonicalToolName === "EventFinderTool" && tool.argsSchema.required?.includes("keyword") && 
          (!actualToolArgs.keyword || typeof actualToolArgs.keyword !== 'string' || actualToolArgs.keyword.trim() === "") &&
          (!actualToolArgs.classificationName && !actualToolArgs.location) 
        ) {
          if (userInputForFallback && typeof userInputForFallback === 'string' && userInputForFallback.trim()) {
            logger.warn(`${logPrefix} EventFinderTool called by Router without 'keyword' and other primary filters. Using fallback user input as keyword: "${String(userInputForFallback).substring(0,50)}..."`);
            actualToolArgs.keyword = String(userInputForFallback);
          } else {
            logger.warn(`${logPrefix} EventFinderTool requires 'keyword' or other filters, but Router provided none and no fallback. Tool may return broad or no results.`);
          }
        }
        // Now validate arguments after patching
        const stepForValidation: ToolRouterPlanStep = { ...routedToolCall, arguments: actualToolArgs, tool_name: canonicalToolName };
        if (!this.validateToolStep(stepForValidation)) {
          logger.error(`${logPrefix} Tool '${canonicalToolName}' (ID: ${callId.substring(0, 6)}) failed argument validation AFTER fallback. Arguments received: ${JSON.stringify(routedToolCall.arguments)}. Arguments after fallback: ${JSON.stringify(actualToolArgs)}. Skipping.`);
          toolResultsSummaryParts.push(`Error: Tool '${canonicalToolName}' skipped (invalid arguments after fallback).`);
          return { role: "tool" as const, tool_call_id: callId, name: canonicalToolName, content: `Error: Tool '${canonicalToolName}' could not execute due to invalid arguments even after attempting fallback.` };
        }
        logger.info(`${logPrefix} Executing tool '${canonicalToolName}' (ID: ${callId.substring(0, 6)}) from Router with final Args: ${JSON.stringify(actualToolArgs).substring(0, 100)}`);
        const abortController = new AbortController();
        const timeoutDuration = (typeof tool.timeoutMs === 'number')
          ? tool.timeoutMs
          : (appConfig as any).toolTimeoutMs || DEFAULT_TOOL_TIMEOUT_MS;
        logger.debug(`${logPrefix} Timeout configured for ${tool.name}: ${timeoutDuration}ms`);
        const timeoutId = setTimeout(() => {
          logger.warn(`${logPrefix} Timeout after ${timeoutDuration}ms for ${tool.name} (ID: ${callId.substring(0, 6)})`);
          abortController.abort();
        }, timeoutDuration);
        try {
          const toolInput: ToolInput = {
            ...(actualToolArgs as Record<string, any>),
            userId,
            lang: apiContext?.lang || userState?.preferred_locale?.split("-")[0] || (appConfig as any).defaultLocale.split("-")[0],
            sessionId: apiContext?.sessionId,
            context: { ...(apiContext || {}), userState, sessionId: apiContext?.sessionId, runId: apiContext?.runId, userName: await this.getUserFirstName(userId), abortSignal: abortController.signal, workflowVariables: {} },
          };
          const output: ToolOutput = await tool.execute(toolInput, abortController.signal);
          clearTimeout(timeoutId);
          logger.info(`${logPrefix} Tool '${tool.name}' (ID: ${callId.substring(0, 6)}) finished. Success: ${!output.error}`);
          if (!output.error && output.structuredData) {
            structuredDataMap.set(callId, output.structuredData);
          } else {
            structuredDataMap.set(callId, null);
          }
          const resultString = output.error ? `Error from ${tool.name}: ${String(output.error)}` : String(output.result || `${tool.name} completed.`).substring(0, 4000);
          toolResultsSummaryParts.push(`Result from ${tool.name}: ${resultString.substring(0, 150)}...`);
          logToolExecution({
            toolName: canonicalToolName,
            aliasUsed: toolNameFromRouter !== canonicalToolName ? toolNameFromRouter : undefined,
            arguments: actualToolArgs,
            result: output.result,
            error: output.error,
            userId,
            structuredData: output.structuredData,
            success: !output.error,
          });
          return { role: "tool" as const, tool_call_id: callId, name: canonicalToolName, content: resultString };
        } catch (error: any) {
          clearTimeout(timeoutId);
          const isAbort = error.name === 'AbortError' || abortController.signal.aborted;
          const errorMsg = isAbort ? `Tool '${canonicalToolName}' timed out.` : `Tool '${canonicalToolName}' error: ${String(error?.message || error)}`;
          logger.error(`${logPrefix} Tool '${canonicalToolName}' (ID: ${callId.substring(0, 6)}) ${isAbort ? "TIMEOUT" : "EXCEPTION"}: ${String(error?.message || error)}`);
          structuredDataMap.set(callId, null);
          toolResultsSummaryParts.push(`Error with ${tool.name}: ${errorMsg.substring(0, 100)}...`);
          logToolExecution({
            toolName: canonicalToolName,
            aliasUsed: toolNameFromRouter !== canonicalToolName ? toolNameFromRouter : undefined,
            arguments: actualToolArgs,
            error: errorMsg,
            userId,
            success: false,
          });
          return { role: "tool" as const, tool_call_id: callId, name: canonicalToolName, content: `Error: ${errorMsg}` };
        }
    });
    const settledResults = await Promise.allSettled(executionPromises);
    let lastSuccessfulStructuredData: AnyToolStructuredData | null = null;
    // Track tools that need special transition handling
    let needsStripeOnboarding = false;
    let savedProductDetails: any = null;
    let returnToPaymentLinkAfterOnboarding = false;
    let previousToolName = "";
    
    for (let i = 0; i < settledResults.length; i++) {
      const result = settledResults[i];
      const originalRoutedCall = toolCallsFromRouter[i]; // Assuming toolCallsFromRouter matches the order of executionPromises
      if (result.status === "fulfilled" && result.value) {
        const toolMessage = result.value as ChatMessage; // Type assertion
        toolResultsMessages.push(toolMessage);
        const callId = (typeof (toolMessage as any).tool_call_id === 'string' && (toolMessage as any).tool_call_id) ? (toolMessage as any).tool_call_id : `fallback_id_${i}`;
        
        // Check for special StripePaymentLinkTool to StripeSellerOnboardingTool transition
        if (
          structuredDataMap.has(callId) && 
          originalRoutedCall.tool_name === "StripePaymentLinkTool"
        ) {
          const data = structuredDataMap.get(callId);
          if (
            data && 
            data.result_type === "payment_link" && 
            'next_step' in data && 
            data.next_step === "redirect_to_onboarding" && 
            'needs_onboarding' in data && 
            data.needs_onboarding === true &&
            'saved_product_details' in data &&
            data.saved_product_details
          ) {
            logger.info(`[Orchestrator] Detected need to transition from StripePaymentLinkTool to StripeSellerOnboardingTool`);
            needsStripeOnboarding = true;
            savedProductDetails = data.saved_product_details;
            previousToolName = "StripePaymentLinkTool";
          }
        }
        
        // Check for StripeSellerOnboardingTool returning to StripePaymentLinkTool
        if (
          structuredDataMap.has(callId) && 
          originalRoutedCall.tool_name === "StripeSellerOnboardingTool"
        ) {
          const data = structuredDataMap.get(callId);
          if (
            data && 
            data.result_type === "seller_onboarding" && 
            'return_to_payment_link_after' in data && 
            data.return_to_payment_link_after === true &&
            'saved_product_details' in data && 
            data.saved_product_details
          ) {
            logger.info(`[Orchestrator] Detected completion of StripeSellerOnboardingTool, should return to StripePaymentLinkTool`);
            returnToPaymentLinkAfterOnboarding = true;
            savedProductDetails = data.saved_product_details;
            previousToolName = "StripeSellerOnboardingTool";
          }
        }
        
        // Check if content indicates an error before considering structuredData
        if (
          typeof toolMessage.content === 'string' &&
          !toolMessage.content.startsWith("Error:") &&
          !toolMessage.content.startsWith(`Error from ${toolMessage.name}:`) &&
          structuredDataMap.has(callId)
        ) {
          const data = structuredDataMap.get(callId);
          if (data) lastSuccessfulStructuredData = data;
        }
      } else if (result.status === "rejected") {
        logger.error(`${logPrefix} Unexpected parallel exec error for tool call ${originalRoutedCall.tool_name}:`, result.reason);
        toolResultsMessages.push({ role: "tool", tool_call_id: `toolcall_${randomUUID()}`, name: originalRoutedCall.tool_name, content: `Error: Internal error executing ${originalRoutedCall.tool_name}.` } as ChatMessage);
        toolResultsSummaryParts.push(`Error: Internal error executing ${originalRoutedCall.tool_name}.`);
      }
    }
    
    // Handle the special tool transitions if needed
    if (needsStripeOnboarding && savedProductDetails) {
      logger.info(`[Orchestrator] Triggering StripeSellerOnboardingTool after StripePaymentLinkTool`);
      
      // Prepare arguments for the StripeSellerOnboardingTool
      const onboardingArgs = {
        intent: "start_selling",
        country: null,
        entity_type: null,
        business_description: savedProductDetails.product_name ? `selling ${savedProductDetails.product_name}` : null,
        _context: {
          savedProductDetails: savedProductDetails,
          previous_tool: previousToolName,
          userState: userState,
          userId: userId,
          userName: apiContext.userName || "friend"
        },
        _rawUserInput: currentTurnUserInput
      };
      
      try {
        // Find the StripeSellerOnboardingTool
        const { tool } = await this.getResolvedTool("StripeSellerOnboardingTool", userId);
        
        if (tool) {
          logger.info(`[Orchestrator] Found StripeSellerOnboardingTool, executing it`);
          
          // Execute the tool with our arguments
          const onboardingResult = await tool.execute(onboardingArgs);
          
          // Create a tool message for the response
          const onboardingToolMessage: ChatMessage = {
            role: "tool",
            tool_call_id: `auto_transition_${crypto.randomUUID()}`, 
            name: "StripeSellerOnboardingTool",
            content: onboardingResult?.result || null,
            timestamp: new Date().toISOString()
          };
          
          // Add the result to our responses
          toolResultsMessages.push(onboardingToolMessage);
          toolResultsSummaryParts.push(`Transitioned to StripeSellerOnboardingTool: ${
            onboardingResult?.result ? onboardingResult.result.substring(0, 100) + '...' : 'Initiated Stripe account setup'
          }`);
          
          // Update structured data
          if (onboardingResult.structuredData) {
            lastSuccessfulStructuredData = onboardingResult.structuredData as AnyToolStructuredData;
          }
        }
      } catch (error) {
        logger.error(`[Orchestrator] Error transitioning to StripeSellerOnboardingTool:`, error);
      }
    }
    
    if (returnToPaymentLinkAfterOnboarding && savedProductDetails) {
      logger.info(`[Orchestrator] Returning to StripePaymentLinkTool after StripeSellerOnboardingTool completion`);
      
      // Prepare arguments for the StripePaymentLinkTool with saved product details
      const paymentLinkArgs = {
        ...savedProductDetails,
        _context: {
          savedProductDetails: savedProductDetails,
          previous_tool: previousToolName,
          userState: userState,
          userId: userId,
          userName: apiContext.userName || "friend"
        },
        _rawUserInput: "yes continue with creating my payment link"
      };
      
      try {
        // Find the StripePaymentLinkTool
        const { tool } = await this.getResolvedTool("StripePaymentLinkTool", userId);
        
        if (tool) {
          logger.info(`[Orchestrator] Found StripePaymentLinkTool, executing it to resume flow`);
          
          // Execute the tool with our saved arguments
          const paymentLinkResult = await tool.execute(paymentLinkArgs);
          
          // Create a tool message for the response
          const paymentLinkToolMessage: ChatMessage = {
            role: "tool",
            tool_call_id: `auto_transition_${crypto.randomUUID()}`,
            name: "StripePaymentLinkTool",
            content: paymentLinkResult?.result || null,
            timestamp: new Date().toISOString()
          };
          
          // Add the result to our responses
          toolResultsMessages.push(paymentLinkToolMessage);
          toolResultsSummaryParts.push(`Resumed StripePaymentLinkTool: ${
            paymentLinkResult?.result ? paymentLinkResult.result.substring(0, 100) + '...' : 'Resumed payment link creation'
          }`);
          
          // Update structured data
          if (paymentLinkResult.structuredData) {
            lastSuccessfulStructuredData = paymentLinkResult.structuredData as AnyToolStructuredData;
          }
        }
      } catch (error) {
        logger.error(`[Orchestrator] Error returning to StripePaymentLinkTool:`, error);
      }
    }
    
    return { messages: toolResultsMessages, lastSuccessfulStructuredData, llmUsage: null, toolResultsSummary: toolResultsSummaryParts.join("\n") || "Tools processing completed.", clarificationQuestion, clarificationDetails };
  }
  public async runOrchestration(
    userId: string,
    userInput: string | ChatMessageContentPart[],
    history: ChatMessage[] = [],
    apiContext?: Record<string, any>,
    initialAttachments?: MessageAttachment[]
  ): Promise<OrchestratorResponse | OrchestratorResponse[]> {
    const overallStartTime = Date.now();
    const runId = apiContext?.sessionId || apiContext?.runId || `${SESSION_ID_PREFIX}${randomUUID()}`;
    const turnIdentifier = `OrchRun User:${userId.substring(0, 8)} Run:${runId.substring(0, 6)}`;
    // Log initialAttachments received by runOrchestration
    if (initialAttachments) {
      logger.info(`[${turnIdentifier}] runOrchestration received initialAttachments. Count: ${initialAttachments.length}`);
      initialAttachments.forEach((att, index) => {
        logger.info(`[${turnIdentifier}] initialAttachment[${index}]: type=${att.type}, name=${att.name}, url=${att.url}, hasFile=${!!att.file}, storagePath=${att.storagePath}`);
      });
    } else {
      logger.info(`[${turnIdentifier}] runOrchestration received NO initialAttachments (null or undefined).`);
    }
    logger.info(`--- ${turnIdentifier} Starting Orchestration Run (Planning: ${PLANNING_MODEL_NAME_ORCH}, Chat/Vision: ${CHAT_VISION_MODEL_NAME_ORCH}) ---`);
    
    // Initialisation des variables
    let finalStructuredResult: AnyToolStructuredData | null = null;
    let finalResponseText: string | null = null;
    let responseIntentType: string | null = "neutral";
    let ttsInstructionsForFinalResponse: string | null = null;
    let clarificationQuestionForUser: string | null = null;
    let clarificationDetailsForUser: any = null;
    let llmUsage_total: CompletionUsage = { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 };
    let finalFlowType: DebugFlowType = "error";
    let finalResponseSource: string | null = "Error";
    let currentTurnToolResultsSummary: string | null = null;
    let toolRouterFollowUpSuggestion: string | null = null;
    let finalToolCallsLogged: any[] = [];
    let videoSummaryForContext: string | null = null;
    let textQueryForRouter: string = "";
    let mainUserInputContent: ChatMessageContentPart[] = [];
    let retrievedMemoryContext: string = "INTERNAL CONTEXT - RELEVANT MEMORIES: None found or not applicable for this turn.";
    let messagesForGpt4o: ChatMessage[] = [];
    let routedTools: ToolRouterPlan = { planned_tools: [] };
    let userName: string = DEFAULT_USER_NAME;
    let lang: string = "en";
    // AJOUT: Initialisation de toolExecutionMessages
    let toolExecutionMessages: ChatMessage[] = [];
    
    // Check if enhanced orchestration should be used
    const useEnhancedOrchestration = apiContext?.useEnhancedOrchestration === true || appConfig.minato?.useEnhancedOrchestration === true;
    
    if (useEnhancedOrchestration && typeof userInput === 'string') {
      logger.info(`[${turnIdentifier}] Using enhanced orchestration with XML planning.`);
      
      // Get user information
      userName = await this.getUserFirstName(userId);
      
      // Get user state and persona customization
      const userState = await (async () => {
        try {
          if (userId) {
            return await supabaseAdmin.getUserState(userId);
          }
          return null;
        } catch (e) {
          logger.warn(`[${turnIdentifier}] Could not load user state:`, e);
          return null;
        }
      })();
      
      // Get persona customization
      const personaId = userState?.active_persona_id || DEFAULT_PERSONA_ID;
      const personaCustomization = await (async () => {
        try {
          if (personaId) {
            const persona = await this.memoryFramework.getPersonaById(personaId, userId);
            return persona?.system_prompt || null;
          }
          return null;
        } catch (e) {
          logger.warn(`[${turnIdentifier}] Could not load persona:`, e);
          return null;
        }
      })();
      
      // Get user state summary
      const userStateSummary = summarizeUserStateForWorkflow(userState);
      
      // For now, skip enhanced orchestration due to integration issues
      const enhancedResult = { 
        error: "Enhanced orchestration temporarily disabled for integration fixes" 
      };
      
      // If there was an error, fallback to standard orchestration
      if (enhancedResult.error) {
        logger.warn(`[${turnIdentifier}] Enhanced orchestration failed: ${enhancedResult.error}. Falling back to standard orchestration.`);
      } else {
        // Process the enhanced orchestration result
        finalStructuredResult = enhancedResult.structuredData;
        currentTurnToolResultsSummary = enhancedResult.toolResultsSummary;
        
        // Use the enhanced orchestration result for synthesis if available
        if (enhancedResult.responseText) {
          finalResponseText = enhancedResult.responseText;
          responseIntentType = "neutral"; // Default intent type
          finalFlowType = "enhanced_orchestration";
          finalResponseSource = "Enhanced Orchestration";
          ttsInstructionsForFinalResponse = getDynamicInstructions(responseIntentType);
          
          // Complete the orchestration
          const orchestrationMs = Date.now() - overallStartTime;
          
          // Create the response object
          const baseOrchestratorResponse = {
            sessionId: runId,
            error: null,
            lang: apiContext?.lang || appConfig.defaultLocale || "en",
            intentType: responseIntentType,
            ttsInstructions: ttsInstructionsForFinalResponse,
            clarificationQuestion: null,
            clarificationDetails: null,
            audioUrl: null,
            workflowFeedback: null,
            debugInfo: {
              flow_type: finalFlowType,
              llmModelUsed: CHAT_VISION_MODEL_NAME_ORCH,
              workflowPlannerModelUsed: PLANNING_MODEL_NAME_ORCH,
              llmUsage: enhancedResult.llmUsage || llmUsage_total,
              latencyMs: orchestrationMs,
              toolCalls: [],
              videoSummaryUsed: null,
            },
            transcription: null,
            llmUsage: enhancedResult.llmUsage || llmUsage_total,
            attachments: initialAttachments,
          };
          
          if (finalResponseText !== null) {
            return {
              ...baseOrchestratorResponse,
              response: finalResponseText,
              structuredData: finalStructuredResult,
                  };
     }
   }
  
      }
    
    // If enhanced orchestration was not used or failed, fallback to standard orchestration
    // Variables are already initialized above, reset them if needed
    finalStructuredResult = null;
    finalResponseText = null;
    responseIntentType = "neutral";
    ttsInstructionsForFinalResponse = null;
    clarificationQuestionForUser = null;
    clarificationDetailsForUser = null;
    llmUsage_total = { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 };
    finalFlowType = "error";
    finalResponseSource = "Error";
    currentTurnToolResultsSummary = null;
    toolRouterFollowUpSuggestion = null;
    finalToolCallsLogged = [];
    videoSummaryForContext = null;
    textQueryForRouter = "";
    mainUserInputContent = [];
    retrievedMemoryContext = "INTERNAL CONTEXT - RELEVANT MEMORIES: None found or not applicable for this turn.";
    messagesForGpt4o = [];
    routedTools = { planned_tools: [] };
    // userName is already initialized
    lang = "en";
    // Reset toolExecutionMessages
    toolExecutionMessages = [];
    
    // Always fetch fresh user state to ensure we have the latest persona selection
    const userState: UserState | null = await supabaseAdmin.getUserState(userId);
    
    let personaId = userState?.active_persona_id || DEFAULT_PERSONA_ID;
    let personaNameForPrompt = "Minato";
    let personaSpecificInstructions = "You are Minato, a helpful, friendly, and knowledgeable AI assistant.";
    
    logger.info(`[${turnIdentifier}] Using persona ID: ${personaId} for user ${userId.substring(0, 8)}`);
    
    try { // Bloc try principal
      userName = await this.getUserFirstName(userId);
      lang = apiContext?.lang || userState?.preferred_locale?.split("-")[0] || (appConfig as any).defaultLocale.split("-")[0] || "en";
      const effectiveApiContext = { ...(apiContext || {}), userName, lang, locale: userState?.preferred_locale || (appConfig as any).defaultLocale, runId };
      
      try { // Bloc try pour la récupération de la persona (ceci est OK)
        const persona = await this.memoryFramework.getPersonaById(personaId, userId);
        if (persona?.system_prompt) {
          personaSpecificInstructions = persona.system_prompt;
          personaNameForPrompt = persona.name || personaId;
          logger.info(`[${turnIdentifier}] Loaded persona "${personaNameForPrompt}" with custom instructions (${personaSpecificInstructions.length} chars) and voice: ${persona.voice_id || 'none'}`);
        } else {
          logger.warn(`[${turnIdentifier}] Persona ${personaId} not found or has no system_prompt, using defaults`);
        }
      } catch (e: any) { 
        logger.error(`[${turnIdentifier}] Error fetching persona ${personaId}:`, e.message); 
      }
      if (typeof userInput === 'string') {
        textQueryForRouter = userInput;
        mainUserInputContent.push({ type: "text", text: userInput });
      } else {
        mainUserInputContent = [...userInput];
        const textPart = userInput.find(p => p.type === 'text') as ChatMessageContentPartText | undefined;
        textQueryForRouter = textPart?.text || "";
        // Pre-process image parts from mainUserInputContent if they have blob URLs or placeholder IDs
        // by finding their corresponding File object in initialAttachments and uploading.
        if (initialAttachments && initialAttachments.length > 0) {
          logger.debug(`[${turnIdentifier}] Processing ${initialAttachments.length} initial attachments for vision input preparation.`);
          const adminClient = getSupabaseAdminClient();
          if (!adminClient) {
            logger.error(`[${turnIdentifier}] Supabase admin client is not available. Cannot process file attachments for vision.`);
          } else {
            for (let i = 0; i < mainUserInputContent.length; i++) {
              const part = mainUserInputContent[i];
              if (part.type === "input_image") {
                const imagePartToProcess = part as ChatMessageContentPartInputImage;
                let matchingAttachment: MessageAttachment | undefined = undefined;
                if (imagePartToProcess.image_url.startsWith("blob:") || imagePartToProcess.image_url.startsWith("placeholder_id_")) {
                  const idToMatch = imagePartToProcess.image_url.startsWith("placeholder_id_") 
                    ? imagePartToProcess.image_url.substring("placeholder_id_".length) 
                    : imagePartToProcess.image_url; 
                  matchingAttachment = initialAttachments.find(att => (att.url === idToMatch || att.id === idToMatch) && att.file);
                  logger.debug(`[${turnIdentifier}] Attempting to match content part URL/ID "${idToMatch.substring(0,60)}" with initial attachments. Found: ${!!matchingAttachment}, File: ${matchingAttachment?.file && matchingAttachment.file instanceof File ? matchingAttachment.file.name : 'unknown'}`);
                }
                if (matchingAttachment && matchingAttachment.file) {
                  try {
                    const fileToUpload = matchingAttachment.file;
                    const originalUrlForLog = imagePartToProcess.image_url;
                    const fileName = (fileToUpload instanceof File && fileToUpload.name) ? fileToUpload.name.replace(/[^a-zA-Z0-9._-]/g, "_") : randomUUID();
                    const fileExtension = (fileName.includes('.') ? fileName.split('.').pop() : 'bin') || 'bin';
                    const filePath = `user_uploads/${userId}/${Date.now()}_${randomUUID().substring(0,8)}.${fileExtension}`;
                    logger.info(`[${turnIdentifier}] Uploading image "${fileName}" (from URL: ${originalUrlForLog.substring(0,60)}) to Supabase at ${MEDIA_UPLOAD_BUCKET}/${filePath}`);
                    const { data: uploadData, error: uploadError } = await adminClient.storage
                      .from(MEDIA_UPLOAD_BUCKET)
                      .upload(filePath, fileToUpload, { contentType: fileToUpload.type || 'application/octet-stream', upsert: true });
                    if (uploadError) {
                      logger.error(`[${turnIdentifier}] Supabase image upload failed for "${fileName}": ${uploadError.message}`);
                      if (fileToUpload.size < 5 * 1024 * 1024) { 
                        const arrayBuffer = await fileToUpload.arrayBuffer();
                        const base64String = Buffer.from(arrayBuffer).toString('base64');
                        imagePartToProcess.image_url = `data:${fileToUpload.type || 'image/jpeg'};base64,${base64String}`;
                        logger.info(`[${turnIdentifier}] Used base64 data URL fallback for image "${fileName}".`);
                      } else {
                        imagePartToProcess.image_url = "error_uploading_image_too_large_for_base64";
                      }
                    } else {
                      const { data: publicUrlData } = adminClient.storage.from(MEDIA_UPLOAD_BUCKET).getPublicUrl(uploadData.path);
                      if (publicUrlData?.publicUrl) {
                        imagePartToProcess.image_url = publicUrlData.publicUrl; 
                        logger.info(`[${turnIdentifier}] Image "${fileName}" uploaded. Public URL for content part: ${publicUrlData.publicUrl.substring(0,100)}`);
                        const attIndex = initialAttachments.findIndex(att => att.id === matchingAttachment!.id || att.url === originalUrlForLog);
                        if (attIndex !== -1) {
                          initialAttachments[attIndex].url = publicUrlData.publicUrl;
                          initialAttachments[attIndex].storagePath = uploadData.path;
                          delete initialAttachments[attIndex].file; 
                        }
                      } else {
                        logger.error(`[${turnIdentifier}] Failed to get public URL for uploaded image "${fileName}".`);
                        imagePartToProcess.image_url = "error_getting_public_url";
                      }
                    }
                  } catch (e: any) {
                    logger.error(`[${turnIdentifier}] Exception during attachment image upload for URL ${imagePartToProcess.image_url}: ${e.message}`);
                    imagePartToProcess.image_url = "error_processing_image_upload";
                  }
                } else if (imagePartToProcess.image_url.startsWith("blob:") || imagePartToProcess.image_url.startsWith("placeholder_id_")) {
                  logger.warn(`[${turnIdentifier}] Image part has URL ${imagePartToProcess.image_url.substring(0,60)} but no matching *File* attachment found or file was already processed.`);
                  if (!imagePartToProcess.image_url.startsWith("http") && !imagePartToProcess.image_url.startsWith("data:")) { 
                    imagePartToProcess.image_url = "error_missing_file_for_url";
                  }
                }
              }
            }
          }
        }
        // Filter imageParts for vision from the potentially updated mainUserInputContent
        let imageParts = mainUserInputContent.filter(p => {
          if (p.type === 'input_image') {
            // Ensure we only process valid URLs, not error placeholders
            return !p.image_url.startsWith("error_");
          }
          return false;
        }) as import("@/lib/types/index").ChatMessageContentPartInputImage[];
        // FINAL FILTER: Only allow valid URLs (http/https) or data URLs (base64)
        imageParts = imageParts.filter(img => {
          const url = img.image_url;
          const isValid = (
            typeof url === 'string' && url !== null && (
              url.startsWith('http://') || url.startsWith('https://') ||
              (url.startsWith('data:image/') && url.includes(';base64,'))
            )
          );
          if (!isValid) {
            logger.warn(`[${turnIdentifier}] Skipping invalid image_url for vision: ${url}`);
          }
          return isValid;
        });
        if (imageParts.length > 0) {
          logger.info(`[${turnIdentifier}] Detected ${imageParts.length} image attachment(s). Generating descriptions.`);
          let imageDescriptions: string[] = [];
          try {
            const visionPromptForDescription = textQueryForRouter || "Describe the content of the provided image(s) in detail. What are the key objects, scenes, and actions?";
            // Construct ChatMessage[] for generateVisionCompletion
            const visionMessages: ChatMessage[] = [
              {
                role: "user",
                content: [
                  { type: "text", text: visionPromptForDescription },
                  ...imageParts.map(img => ({
                    type: "input_image" as const, // This is our internal type
                    image_url: img.image_url,
                    detail: img.detail || "auto"
                  } as import("@/lib/types/index").ChatMessageContentPartInputImage))
                ],
                timestamp: Date.now(),
                // name: userName, // Optional, can be added if needed by generateVisionCompletion or its internals
              }
            ];
            // Log the URLs being sent to generateVisionCompletion
            logger.info(`[${turnIdentifier}] Preparing to call generateVisionCompletion. Vision messages content:`);
            visionMessages.forEach((vm, vmIndex) => {
              if (Array.isArray(vm.content)) {
                vm.content.forEach((contentPart, cpIndex) => {
                  if (contentPart.type === 'input_image') {
                    logger.info(`[${turnIdentifier}] VisionMessage[${vmIndex}]-ContentPart[${cpIndex}](input_image) URL: ${contentPart.image_url}`);
                  } else if (contentPart.type === 'text') {
                    logger.info(`[${turnIdentifier}] VisionMessage[${vmIndex}]-ContentPart[${cpIndex}](text): ${(contentPart.text || "").substring(0, 100)}...`);
                  }
                });
              }
            });
            const visionCompletionResult = await generateVisionCompletion(
              visionMessages, // messages: ChatMessage[]
              CHAT_VISION_MODEL_NAME_ORCH, // modelName?: string
              (appConfig.openai as any).maxVisionTokens || 2048, // maxTokens?: number
              userId // userId?: string
              // No 7th argument (interactionType was incorrect for this function)
            );
            if (visionCompletionResult.text) {
              imageDescriptions.push(visionCompletionResult.text);
              logger.info(`[${turnIdentifier}] Image description(s) generated successfully.`);
            } else if (visionCompletionResult.error) {
              logger.warn(`[${turnIdentifier}] Image description generation failed: ${visionCompletionResult.error}. Proceeding without image summary.`);
              imageDescriptions.push("[Image analysis attempted but failed to produce summary.]");
            } else {
              logger.warn(`[${turnIdentifier}] Image description generation returned no text and no error.`);
              imageDescriptions.push("[Image content present but no textual summary generated.]");
            }
          } catch (visionError: any) {
            logger.error(`[${turnIdentifier}] Error during image description generation: ${visionError.message}`);
            imageDescriptions.push("[Error during image analysis.]");
          }
          if (imageDescriptions.length > 0) {
            textQueryForRouter += (textQueryForRouter ? "\n" : "") + `[Image Content Summary: ${imageDescriptions.join("\n")}]`;
          } else {
            textQueryForRouter += (textQueryForRouter ? " " : "") + "[User sent images/frames - summary unavailable]";
          }
        }
      }
      const videoAttachment = initialAttachments?.find(att => att.type === 'video' && att.file);
      if (videoAttachment && videoAttachment.file) {
        logger.info(`[${turnIdentifier}] Detected video attachment: ${videoAttachment.name}. Initiating analysis.`);
        const videoBuffer = Buffer.from(await videoAttachment.file.arrayBuffer());
        const videoAnalysisResult = await this.videoAnalysisService.analyzeVideo(
          videoBuffer, videoAttachment.name || "uploaded_video",
          videoAttachment.mimeType || "video/mp4",
          textQueryForRouter || "Describe this video.", userId
        );
        if (videoAnalysisResult.summary) {
          videoSummaryForContext = videoAnalysisResult.summary;
          textQueryForRouter += (textQueryForRouter ? "\n" : "") + `[Video Content Summary: ${videoSummaryForContext.substring(0, 200)}...]`;
          // Add visual QA validation (new code)
          try {
            const visualQAResult = await this.videoAnalysisService.generateQA(
              videoBuffer,
              "What are 3 key visual elements? What's the main action? What colors dominate?",
              userId
            );
            if (visualQAResult?.answers?.length > 0) {
              const qaText = `[Visual QA: ${visualQAResult.answers.join("; ").substring(0, 150)}]`;
              textQueryForRouter += `\n${qaText}`;
              logger.info(`${turnIdentifier} Added visual QA to context: ${qaText}`);
            }
          } catch (qaError) {
            const qaErrorMsg = qaError instanceof Error ? qaError.message : String(qaError);
            logger.warn(`${turnIdentifier} Visual QA failed but continuing: ${qaErrorMsg}`);
          }
        } else if (videoAnalysisResult.error) {
          logger.warn(`[${turnIdentifier}] Video analysis failed: ${videoAnalysisResult.error}. Proceeding without video summary.`);
          textQueryForRouter += (textQueryForRouter ? "\n" : "") + "[Video analysis attempted but failed to produce summary.]";
        }
      }
      
      // Determine if this is a media-only upload with minimal text
      const isMediaOnlyMessage = Boolean(
        (initialAttachments?.some(att => att.type === 'video' || att.type === 'image')) &&
        (typeof userInput === 'string' && userInput.trim().length <= 10)
      );
      
      // If the user is just uploading media without asking a specific question
      // modify the query to focus on having a conversation about the media
      if (isMediaOnlyMessage && (textQueryForRouter.includes("[Video Content Summary:") || textQueryForRouter.includes("[Visual QA:"))) {
        // This is a media upload without much user text - make it clear in the prompt
        textQueryForRouter = `[MEDIA UPLOAD: The user has shared media content. Please respond to the content directly in conversation, don't use tools.] ` + textQueryForRouter;
      }
      
      // Check if this is an audio message conversation
      const isAudioMessage = Boolean(
        apiContext?.isAudioMessage === true || 
        apiContext?.transcription || 
        (history.length > 0 && history.some(msg => (msg as any).isAudioMessage === true))
      );
      
      // If this is from a voice/audio message, add a hint to prefer direct conversation
      if (isAudioMessage) {
        logger.info(`[${turnIdentifier}] Audio/voice message detected. Will be more conservative with tool usage.`);
        textQueryForRouter = `[VOICE CONVERSATION: This is a spoken conversation. Respond naturally and avoid using tools unless explicitly requested.] ` + textQueryForRouter;
      }
      
      // Determine if this is any kind of media upload (with or without text)
      const isMediaUpload = Boolean(
        initialAttachments?.some(att => att.type === 'video' || att.type === 'image') ||
        textQueryForRouter.includes("[Video Content Summary:") ||
        textQueryForRouter.includes("[Visual QA:")
      );
      
      // Initialize routedTools - will be populated only if appropriate conditions are met
      let routedTools: ToolRouterPlan = { planned_tools: [] };
      
      // Determine if tool routing should be bypassed
      const bypassToolRouter = isMediaUpload || 
                              (isAudioMessage && textQueryForRouter.trim().split(/\s+/).length < 6) || // Short audio messages
                              (typeof userInput === 'string' && userInput.trim().length < 4 && !userInput.includes("?"));
      
      if (!bypassToolRouter) {
        // Only invoke tool router if conditions are met
        const toolRouterPrompt = injectPromptVariables(TOOL_ROUTER_PROMPT_TEMPLATE, {
          userName, userQuery: textQueryForRouter,
          conversationHistorySummary: summarizeChatHistory(history),
          userStateSummary: summarizeUserStateForWorkflow(userState),
          available_tools_for_planning: this.availableToolsForRouter.map(t => `- ${t.function.name}: ${t.function.description?.substring(0, 100)}...`).join("\n"),
          language: lang, userPersona: personaNameForPrompt,
        });
        
        logger.info(`[${turnIdentifier}] Invoking Tool Router (${PLANNING_MODEL_NAME_ORCH})... Query for router: "${textQueryForRouter.substring(0, 70)}"`);
        
        const routerSchema = {
          type: "object" as const,
          properties: {
            planned_tools: {
              type: "array" as const,
              items: {
                type: "object" as const,
                properties: {
                  tool_name: { type: "string" as const },
                  arguments: {
                    type: "object" as const,
                    additionalProperties: false, // Must be set to false as required by OpenAI API
                    properties: {
                      product_name: { type: ["string", "null"] },
                      price: { type: ["number", "null"] },
                      currency: { type: ["string", "null"] },
                      description: { type: ["string", "null"] },
                      step: { type: ["string", "null"] },
                      intent: { type: ["string", "null"] },
                      country: { type: ["string", "null"] },
                      entity_type: { type: ["string", "null"] },
                      business_description: { type: ["string", "null"] }
                    },
                    required: ["product_name", "price", "currency", "description", "step", "intent", "country", "entity_type", "business_description"]
                  },
                  reason: { type: "string" as const }
                },
                required: ["tool_name", "reason", "arguments"],
                additionalProperties: false
              }
            }
          },
          required: ["planned_tools"],
          additionalProperties: false
        };
        
        const routerResult = await generateStructuredJson<ToolRouterPlan>(
          toolRouterPrompt, textQueryForRouter,
          routerSchema,
          "tool_router_v1_1",
          history.filter(m => typeof m.content === 'string'),
          PLANNING_MODEL_NAME_ORCH, userId
        );
        
        if ("error" in routerResult) {
          logger.error(`[${turnIdentifier}] Tool Router (${PLANNING_MODEL_NAME_ORCH}) failed: ${routerResult.error}. Proceeding without tools.`);
          finalFlowType = "direct_llm_after_router_fail";
        } else {
          routedTools = routerResult;
          finalToolCallsLogged = routedTools.planned_tools.map(rt => ({ toolName: rt.tool_name, args: rt.arguments, reason: rt.reason }));
          logger.info(`[${turnIdentifier}] Tool Router selected ${routedTools.planned_tools.length} tools: ${routedTools.planned_tools.map(t => t.tool_name).join(', ')}`);
          finalFlowType = routedTools.planned_tools.length > 0 ? "workflow_routed" : "direct_llm_no_tools_routed";
        }
      } else {
        // Log that we're skipping tool router for media uploads
        logger.info(`[${turnIdentifier}] Skipping Tool Router for media upload. Proceeding with direct conversation.`);
        finalFlowType = "direct_media_conversation";
      }
      // toolExecutionMessages est déjà initialisé à [] au début de la fonction
      if (routedTools.planned_tools.length > 0) {
        const executionResult = await this.executeToolCalls(
          userId,
          textQueryForRouter, // PASSED: textQueryForRouter as currentTurnUserInput
          routedTools.planned_tools,
          effectiveApiContext,
          userState,
          history
        );
        toolExecutionMessages = executionResult.messages; // Assignation à la variable de la portée supérieure
        finalStructuredResult = executionResult.lastSuccessfulStructuredData;
        currentTurnToolResultsSummary = executionResult.toolResultsSummary;
        clarificationQuestionForUser = executionResult.clarificationQuestion ?? null;
        clarificationDetailsForUser = executionResult.clarificationDetails ?? null;
      }
      // messagesForGpt4o est déjà initialisé à [] au début de la fonction
      messagesForGpt4o = [
        ...history,
        { role: "user", content: mainUserInputContent, name: userName, timestamp: Date.now(), attachments: initialAttachments?.filter(att => att.type !== 'video') },
        ...toolExecutionMessages,
      ];
      // Prepend a system message with the tool's result/summary if present
      if (toolExecutionMessages.length > 0 && typeof toolExecutionMessages[0].content === 'string' && toolExecutionMessages[0].content.trim()) {
        messagesForGpt4o.unshift({
          role: 'system',
          content: `TOOL SUMMARY: ${toolExecutionMessages[0].content}`,
          timestamp: Date.now()
        });
      }
      // Prepare a single, strong system message for video context if it exists
      if (videoSummaryForContext) {
        messagesForGpt4o.unshift({
          role: "system",
          content: `SUMMARY: ${videoSummaryForContext}`,
          timestamp: Date.now()
        });
      }
      const visualQaMatch = textQueryForRouter.match(/\[Visual QA: ([^\]]+)\]/);
      if (visualQaMatch && visualQaMatch[1]) {
        messagesForGpt4o.push({
          role: "system",
          content: `VISUAL QA: ${visualQaMatch[1]}`,
          timestamp: Date.now()
        });
      }
      const videoContextString = videoSummaryForContext ? `YOU MUST BASE YOUR RESPONSE ON THE FOLLOWING VIDEO ANALYSIS. Do NOT ignore this.\n${videoSummaryForContext}` : null;
      if (videoContextString) {
        messagesForGpt4o.push({
          role: "system",
          content: videoContextString,
          timestamp: Date.now()
        });
      }
      if (videoSummaryForContext && !initialAttachments?.find(att => att.type === 'video')) {
        messagesForGpt4o.push({ role: "system", content: `Context from attached video: ${videoSummaryForContext}`, timestamp: Date.now() });
      }
      // retrievedMemoryContext est déjà initialisé au début de la fonction
      const entitiesForMemorySearch: string[] = [textQueryForRouter.substring(0, 70)];
      // Ensure finalStructuredResult is not null and has a title property (with type safety)
      if (finalStructuredResult && typeof (finalStructuredResult as any).title === 'string') {
        entitiesForMemorySearch.push((finalStructuredResult as any).title);
      }
      if (entitiesForMemorySearch.length > 0 && entitiesForMemorySearch.some(e => e.trim() !== "")) {
        logger.info(`[${turnIdentifier}] Performing targeted memory search for ${CHAT_VISION_MODEL_NAME_ORCH}... Entities: ${entitiesForMemorySearch.join('; ').substring(0, 100)}`);
        const memoryResults = await this.memoryFramework.search_memory(entitiesForMemorySearch.join(" "), userId, { limit: 3, offset: 0 }, runId, { enableHybridSearch: true, enableGraphSearch: false, enableConflictResolution: true });
        if (memoryResults.results.length > 0) {
          retrievedMemoryContext = `INTERNAL CONTEXT - RELEVANT MEMORIES (Use these to add helpful related context for ${userName}):\n${memoryResults.results.map(r => `- ${r.content.substring(0, 150)}...`).join("\n")}`;
        }
      }
    } catch (error: any) { // Catch du bloc try principal
      const duration = Date.now() - overallStartTime;
      const errorMessageString = String(error?.message || error || "Orchestration process failed unexpectedly.");
      logger.error(`--- ${turnIdentifier} Orchestration FAILED (${duration}ms): ${errorMessageString}`, error.stack);
      let errorMsg = errorMessageString; if (error.cause) errorMsg = `${errorMsg} (Cause: ${String(error.cause)})`;
      finalFlowType = 'error'; finalResponseSource = "Orchestration Exception";
      if (userId) { const errorMemText = `Minato error for ${userName}: ${errorMsg}`.substring(0, 350); this.memoryFramework.add_memory([], userId, runId, errorMemText).catch(memErr => logger.error(`[${turnIdentifier}] Failed logging orch error to memory:`, memErr)); }
      const userNameForError = userName || DEFAULT_USER_NAME; responseIntentType = "apologetic";
      return { sessionId: runId, response: `I apologize, ${userNameForError}. I encountered an internal error. Minato is looking into it.`, error: errorMsg, lang: lang, audioUrl: null, intentType: responseIntentType, ttsInstructions: getDynamicInstructions(responseIntentType), debugInfo: { flow_type: 'error', llmUsage: llmUsage_total, latencyMs: duration }, workflowFeedback: null, clarificationQuestion: undefined, structuredData: null, transcription: typeof userInput === 'string' && apiContext?.transcription ? apiContext.transcription : null, llmUsage: llmUsage_total, attachments: initialAttachments };
    }
    // Prepare video context for synthesis prompt
    let videoContextParts: string[] = [];
    if (videoSummaryForContext) videoContextParts.push(`SUMMARY: ${videoSummaryForContext}`);
    const visualQaMatch = textQueryForRouter.match(/\[Visual QA: ([^\]]+)\]/);
    if (visualQaMatch && visualQaMatch[1]) {
      videoContextParts.push(`VISUAL QA: ${visualQaMatch[1]}`);
    }
    
    // Enhanced media handling - make it more prominent for synthesis
    const isMediaPresent = initialAttachments?.some(att => att.type === 'video' || att.type === 'image') || 
                           Boolean(videoSummaryForContext) || 
                           Boolean(visualQaMatch);
    
    const videoContextString = videoContextParts.length
      ? `YOU MUST BASE YOUR RESPONSE ON THE FOLLOWING VIDEO ANALYSIS. Do NOT ignore this.\n${videoContextParts.join('\n')}`
      : null;
      
    // Special instruction for media content
    const mediaInstruction = isMediaPresent 
      ? `\n\nIMPORTANT: The user has shared media content (video/image). Make your response focused primarily on discussing this media. Reference specific details from the analysis, acknowledge what they've shared, and make it feel like a natural conversation about their content.`
      : '';
      
    const synthesisSystemPrompt = injectPromptVariables(RESPONSE_SYNTHESIS_PROMPT_TEMPLATE, {
      userName,
      originalQuery: textQueryForRouter,
      toolResultsSummary: currentTurnToolResultsSummary || "No tools were executed by Minato this turn, or their results are directly integrated.",
      language: lang,
      personaCustomization: personaSpecificInstructions || `Minato is a helpful, supportive AI companion for ${userName}.`
    });
    
    // Add explicit instruction for LLM to always include tool-provided summaries in the chat response
    const synthesisSystemPromptWithSummaryInstruction =
      `${synthesisSystemPrompt}

IMPORTANT ADDITIONAL GUIDANCE:
1. If any tool provided a summary of its findings (news, search results, etc.), INCLUDE that summary in your response.
2. Make the summary engaging and conversational, fully integrated with your persona.
3. NEVER mention tool names, APIs, or implementation details.
4. If video context was provided, incorporate insights from it naturally.${mediaInstruction}
${videoContextString ? `\n${videoContextString}` : ''}`;
    logger.info(`[${turnIdentifier}] Synthesizing final response (${CHAT_VISION_MODEL_NAME_ORCH})...`);
    const synthesisResult = await generateStructuredJson<{ responseText: string; intentType: string }>(
      synthesisSystemPromptWithSummaryInstruction, textQueryForRouter, // textQueryForRouter for user message context in synthesis
      {
        type: "object",
        properties: { responseText: { type: "string" }, intentType: { type: "string", enum: Object.keys(TTS_INSTRUCTION_MAP) } },
        required: ["responseText", "intentType"],
        additionalProperties: false,
      },
      "minato_gpt4o_synthesis_v1",
      messagesForGpt4o, // messagesForGpt4o contains full context including tool results
      CHAT_VISION_MODEL_NAME_ORCH,
      userId
    );
    const synthesisLlmUsage = (synthesisResult as any).usage as CompletionUsage | undefined;
    if (synthesisLlmUsage) {
      llmUsage_total.prompt_tokens += synthesisLlmUsage.prompt_tokens || 0;
      llmUsage_total.completion_tokens += synthesisLlmUsage.completion_tokens || 0;
      llmUsage_total.total_tokens += synthesisLlmUsage.total_tokens || 0;
    }
    if ("error" in synthesisResult) {
      finalResponseText = `I've processed your request, ${userName}, but I'm having a bit of trouble wording my reply. ${synthesisResult.error?.substring(0, 100) || "Could you try rephrasing?"}`;
      responseIntentType = "apologetic";
      finalFlowType = "synthesis_error"; // Keep this distinct from direct_llm_after_router_fail
      logger.error(`[${turnIdentifier}] ${CHAT_VISION_MODEL_NAME_ORCH} Synthesis LLM failed: ${synthesisResult.error}`);
    } else {
      finalResponseText = synthesisResult.responseText;
      responseIntentType = synthesisResult.intentType;
      if (finalFlowType !== "direct_llm_after_router_fail") { // Only update if not already set by router failure
        finalFlowType = routedTools.planned_tools.length > 0 ? "workflow_synthesis" : "direct_llm_synthesis";
      }
    }
    ttsInstructionsForFinalResponse = getDynamicInstructions(responseIntentType);
    finalResponseSource = CHAT_VISION_MODEL_NAME_ORCH + " Synthesis";
    const userMemoryMsgForAdd: MemoryFrameworkMessage | null = mainUserInputContent.length > 0
      ? { role: 'user', content: chatMessageContentPartsToMessageParts(mainUserInputContent), name: userName }
      : null;
    const finalAssistantMemoryMsg: MemoryFrameworkMessage | null = finalResponseText ? { role: 'assistant', content: finalResponseText, name: "Minato" } : null;
    const finalTurnForMemory: MemoryFrameworkMessage[] = [userMemoryMsgForAdd, finalAssistantMemoryMsg].filter((m): m is MemoryFrameworkMessage => m !== null);
    if (finalTurnForMemory.length > 0) { this.memoryFramework.add_memory(finalTurnForMemory, userId, runId, null).then(success => logger.info(`[${turnIdentifier}] Async memory add OK: ${success}.`)).catch(e => logger.error(`[${turnIdentifier}] Async memory add FAIL:`, e.message)); }
    const orchestrationMs = Date.now() - overallStartTime;
    finalResponseText = finalResponseText ? injectPromptVariables(finalResponseText, { userName }) : null;
    const debugInfoInternal: OrchestratorResponse['debugInfo'] = {
      flow_type: finalFlowType,
      llmModelUsed: CHAT_VISION_MODEL_NAME_ORCH,
      workflowPlannerModelUsed: PLANNING_MODEL_NAME_ORCH,
      llmUsage: llmUsage_total,
      latencyMs: orchestrationMs,
      toolCalls: finalToolCallsLogged,
      videoSummaryUsed: videoSummaryForContext ? videoSummaryForContext.substring(0, 100) + "..." : null,
    };
    logger.info(`--- ${turnIdentifier} Orchestration complete (${orchestrationMs}ms). Flow: ${finalFlowType}. ---`);
    // Limit the number of planned tools to a maximum of four
    routedTools.planned_tools = routedTools.planned_tools.slice(0, 4);

    // Prepare the base response object for both summary and card
    const baseOrchestratorResponse = {
      sessionId: runId,
      error: (typeof finalFlowType === 'string' && finalFlowType.includes("error")) ? (finalResponseText || "Processing error") : null,
      lang: lang,
      intentType: responseIntentType,
      ttsInstructions: ttsInstructionsForFinalResponse,
      clarificationQuestion: clarificationQuestionForUser ?? null,
      clarificationDetails: clarificationDetailsForUser ?? null,
      audioUrl: null,
      workflowFeedback: null,
      debugInfo: debugInfoInternal,
      transcription: typeof userInput === 'string' && apiContext?.transcription ? apiContext.transcription : (textQueryForRouter !== (typeof userInput === 'string' ? userInput : (userInput.find(p => p.type === 'text') as ChatMessageContentPartText)?.text || '')) ? textQueryForRouter : null,
      llmUsage: llmUsage_total,
      attachments: initialAttachments,
    };

    // --- PATCH: Always wrap HackerNewsTool results in hn_stories structuredData ---
    if (
      routedTools.planned_tools.length === 1 &&
      routedTools.planned_tools[0].tool_name === "HackerNewsTool"
    ) {
      // If finalStructuredResult is missing or not hn_stories, wrap it
      if (!finalStructuredResult || (typeof finalStructuredResult === "object" && finalStructuredResult.result_type !== "hn_stories")) {
        finalStructuredResult = {
          result_type: "hn_stories",
          source_api: "hackernews",
          query: {},
          sourceDescription: "No stories found or error.",
          count: 0,
          stories: [],
          error: typeof finalResponseText === "string" ? finalResponseText : "No stories found or error."
        };
      }
    }

    // If both a summary and structuredData are present, return both as separate messages
    if (
      finalResponseText &&
      finalStructuredResult &&
      typeof finalResponseText === "string" &&
      (finalStructuredResult as any).result_type === "news_articles"
    ) {
      return {
        ...baseOrchestratorResponse,
        response: finalResponseText,
        structuredData: finalStructuredResult,
      };
    }

    // Otherwise, return the single response as before
    return {
      ...baseOrchestratorResponse,
      response: finalResponseText,
      structuredData: finalStructuredResult,
    };
  }

  /**
   * Process a text message from the user
   * @param userId User ID
   * @param text The text message
   * @param history Conversation history
   * @param sessionId Session ID
   * @param apiContext Additional API context
   * @param attachments Message attachments
   * @returns Orchestrator response
   */
  async processTextMessage(
    userId: string,
    text: string | null,
    history: ChatMessage[] = [],
    sessionId?: string,
    apiContext?: Record<string, any>,
    attachments?: MessageAttachment[]
  ): Promise<OrchestratorResponse> {
    let actualSessionId = sessionId || randomUUID();
    const lang = this.detectLanguage(text || "", "en-US");
    
    // Default response when no text is provided
    if (!text) {
      return {
        sessionId: actualSessionId,
        response: "I didn't receive any text to respond to. How can I help you?",
        lang,
        intentType: 'no_text',
        workflowFeedback: null,
        structuredData: null,
        audioUrl: null,
        ttsInstructions: null,
        clarificationQuestion: null,
        clarificationDetails: null,
        debugInfo: {
          flow_type: 'no_text',
          llmModelUsed: null,
          llmUsage: null,
          latencyMs: 0
        }
      };
    }
    
    try {
      // Check if enhanced orchestration is enabled
      if (appConfig.minato?.useEnhancedOrchestration && featureFlags.useXmlStructuredPlanning) {
        // Temporarily disabled for integration fixes
        logger.warn(`[Orchestrator:${userId.slice(0, 6)}] Enhanced orchestration temporarily disabled for integration fixes`);
      }
      
      // Begin tracking time for performance monitoring
      const startTime = Date.now();
      
      // Clean and normalize user input
      const cleanedText = stripSystemPrefixes(text);
      
      // Apply NLU disambiguation if enabled
      let textForOrchestration = cleanedText;
      let nluAnalysis = null;
      
      if (featureFlags.useNluDisambiguation && cleanedText.length >= 5) {
        try {
          // Run NLU disambiguation to resolve ambiguous references
          const disambiguationResult = await runNluDisambiguation(
            userId,
            cleanedText,
            history,
            null, // We'll retrieve user state in the function
            this.memoryFramework
          );
          
          if (disambiguationResult.nluAnalysis) {
            nluAnalysis = disambiguationResult.nluAnalysis;
            textForOrchestration = disambiguationResult.resolvedQuery;
            
            if (textForOrchestration !== cleanedText) {
              logger.info(`[Orchestrator:${userId.slice(0, 6)}] Query disambiguated: "${cleanedText}" -> "${textForOrchestration}"`);
            }
          }
        } catch (error) {
          logger.error(`[Orchestrator:${userId.slice(0, 6)}] NLU disambiguation error:`, error);
          // Continue with original text if disambiguation fails
        }
      }
      
      // Add disambiguation results to apiContext if available
      const enhancedApiContext = {
        ...(apiContext || {}),
        nluAnalysis,
      };
      
      // Dynamic personalization has been disabled
      let enhancedMemoryContext = "";
      let memoryQueries: string[] = [];
      
      // Add memory context to apiContext
      const updatedApiContext = {
        ...enhancedApiContext,
        enhancedMemoryContext,
        memoryQueries
      };
      
      // Add recommended tools from NLU to the API context if available
      if (enhancedApiContext?.nluAnalysis?.potential_tools && 
          Array.isArray(enhancedApiContext.nluAnalysis.potential_tools) && 
          enhancedApiContext.nluAnalysis.potential_tools.length > 0) {
        
        // Add tool recommendations to help optimize tool selection
        const recommendedTools = enhancedApiContext.nluAnalysis.potential_tools;
        updatedApiContext.recommendedTools = recommendedTools;
        logger.info(`[Orch processTextMessage] NLU provided ${recommendedTools.length} recommended tools with confidence scores`);
        
        // Add language information if detected for multilingual support
        if (enhancedApiContext.nluAnalysis.language_detected) {
          const detectedLanguage = enhancedApiContext.nluAnalysis.language_detected;
          updatedApiContext.languageDetected = detectedLanguage;
          if (detectedLanguage !== 'en') {
            logger.info(`[Orch processTextMessage] Processing non-English query in: ${detectedLanguage}`);
          }
        }
      }
      
      // Run the core orchestration
      const orchestrationResult = await this.runOrchestration(
        userId, 
        textForOrchestration, 
        history, 
        updatedApiContext,
        attachments
      );
      
      // Role-based personalization has been disabled
      // No role-based personalization will be applied
      
      // Finalize performance metrics
      const latencyMs = Date.now() - startTime;
      if (orchestrationResult.debugInfo) {
        orchestrationResult.debugInfo.latencyMs = latencyMs;
      }
      
      return orchestrationResult;
    } catch (error) {
      logger.error(`[Orchestrator] processTextMessage error:`, error);
      
      return {
        sessionId: actualSessionId,
        response: "I'm sorry, but I encountered an error processing your request. Please try again.",
        lang,
        intentType: 'error',
        workflowFeedback: null,
        structuredData: null,
        audioUrl: null,
        ttsInstructions: null,
        clarificationQuestion: null,
        clarificationDetails: null,
        debugInfo: {
          flow_type: 'error',
          llmModelUsed: null,
          llmUsage: null,
          latencyMs: 0,
          error: error.message
        }
      };
    }
  }
  
  private async fetchAudioBuffer(url: string): Promise<Buffer> {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const arrayBuffer = await response.arrayBuffer();
      return Buffer.from(arrayBuffer);
    } catch (error: any) {
      logger.error(`[AudioBuffer] Error fetching audio from URL: ${error.message}`);
      throw error;
    }
  }

  /**
   * Verifies a plan against core objectives and directives
   */
  private async verifyMinatoPlanSegment(
    userId: string,
    userQuery: string,
    proposedPlan: XmlPlan,
    history: ChatMessage[],
    personaCustomization: string | null,
    toolRegistry: { [key: string]: BaseTool }
  ): Promise<XmlVerification | null> {
    const logPrefix = `[PlanVerifier User:${userId.substring(0, 8)}]`;
    const planId = `plan-${Date.now().toString(36)}-${Math.random().toString(36).substring(2, 7)}`;
    
    try {
      // Get available tools description
      const availableToolsStringified = getToolDescriptionsForPlanner(toolRegistry);
      
      // Convert the plan to XML format for the verifier
      const planXml = `<plan>
  <goal>${proposedPlan.goal || ''}</goal>
  <reasoning>${proposedPlan.reasoning || ''}</reasoning>
  <steps>
    ${proposedPlan.steps.map(step => `<step>
      <id>${step.id}</id>
      <type>${step.type}</type>
      ${step.toolName ? `<tool_name>${step.toolName}</tool_name>` : ''}
      <arguments>
        ${Object.entries(step.arguments || {}).map(([key, value]) => `<${key}>${value}</${key}>`).join('\n        ')}
      </arguments>
      <description>${step.description || ''}</description>
      <reason>${step.reason || ''}</reason>
      <dependencies>${step.dependencies?.join(',') || ''}</dependencies>
      <parallel>${step.parallel ? 'true' : 'false'}</parallel>
    </step>`).join('\n    ')}
  </steps>
  <is_partial>${proposedPlan.is_partial_plan ? 'true' : 'false'}</is_partial>
  <continuation_summary>${proposedPlan.continuation_summary || ''}</continuation_summary>
</plan>
`;

      // Get the current user profile for additional context
      const userProfile = await this.memoryFramework.getUserProfileSummary(userId);
      const userFirstName = await this.getUserFirstName(userId);
      
      // Create verification prompt
      const verificationPrompt = `
You are verifying a plan for Minato AI to ensure it aligns with Minato's objectives, capabilities, and safety guardrails.

USER QUERY: "${userQuery}"

USER PROFILE: ${userProfile || 'No specific user profile available.'}

PROPOSED PLAN:
${planXml}

AVAILABLE TOOLS:
${availableToolsStringified}

Please verify this plan against Minato's objectives:
1. Ensure all tool usages are appropriate for the task
2. Check that all required tool arguments are properly populated
3. Verify that the steps are in a logical order
4. Confirm that dependencies between steps are correctly specified
5. Ensure the plan properly addresses the user's query
6. Validate that no harmful, unethical, or problematic actions are proposed

Respond with a verification result in XML format:
<verification>
  <plan_id>${planId}</plan_id>
  <is_valid>true/false</is_valid>
  
  <!-- Include only if is_valid is false -->
  <issues>
    <issue>
      <type>tool_misuse|missing_args|logic_error|dependency_error|off_topic|harmful_action</type>
      <description>Clear description of the issue</description>
      <location>step_id or "goal" or "reasoning"</location>
      <severity>critical|important|minor</severity>
      <suggested_fix>Specific suggestion to fix the issue</suggested_fix>
    </issue>
    <!-- additional issues as needed -->
  </issues>
  
  <!-- Include only if there are suggestions for improvement -->
  <suggestions>
    <suggestion>
      <target>step_id or "goal" or "reasoning" or "overall"</target>
      <improvement>Clear description of suggested improvement</improvement>
      <reasoning>Why this improvement would be beneficial</reasoning>
    </suggestion>
    <!-- additional suggestions as needed -->
  </suggestions>
  
  <!-- Include only if is_valid is false and you're providing a corrected plan -->
  <corrected_plan>
    <!-- insert corrected plan XML here with the same structure as the input plan -->
  </corrected_plan>
</verification>
`;
      
      // Prepare to call the AI with the verification prompt
      const llmServiceConfig: LLMServiceConfig = {
        model: appConfig.ai?.modelVersions?.planner || 'gpt-4-turbo-preview',
        temperature: 0.2,
        max_tokens: 3000
      };
      
      // Call the LLM with the verification prompt
      const verificationResponse = await sendToChatLLM(verificationPrompt, llmServiceConfig);
      
      // Parse the XML verification response
      return parseVerificationFromXml(verificationResponse);
    } catch (error) {
      logger.error(`${logPrefix} Error verifying plan: ${error}`);
      return null;
    }
  }

  /**
   * Process an audio message by transcribing it and then handling the resulting text
   * @param userId User ID
   * @param audioUrl URL to the audio file
   * @param history Conversation history
   * @param sessionId Session ID
   * @param apiContext Additional context for the API
   * @returns Orchestrator response
   */
  async processAudioMessage(
    userId: string,
    audioUrl: string,
    history: ChatMessage[] = [],
    sessionId?: string,
    apiContext?: Record<string, any>
  ): Promise<OrchestratorResponse> {
    const logPrefix = `[AudioProcess User:${userId.substring(0, 8)}]`;
    logger.info(`${logPrefix} Processing audio message from URL: ${audioUrl.substring(0, 60)}...`);
    
    try {
      // Fetch audio buffer from URL
      const audioBuffer = await this.fetchAudioBuffer(audioUrl);
      if (!audioBuffer || audioBuffer.length === 0) {
        logger.error(`${logPrefix} Failed to fetch audio data or empty buffer`);
        return {
          sessionId: sessionId || randomUUID(),
          response: "I couldn't process the audio message. Please try again or send a text message instead.",
          lang: "en",
          intentType: 'error',
          workflowFeedback: null,
          structuredData: null,
          audioUrl: null,
          ttsInstructions: null,
          clarificationQuestion: null,
          clarificationDetails: null,
          transcription: null,
          debugInfo: {
            flow_type: 'error',
            llmModelUsed: null,
            llmUsage: null,
            latencyMs: 0,
            error: "Failed to fetch audio data"
          }
        };
      }
      
      // Detect content type from API context if available
      const detectedMimeType = apiContext?.detectedMimeType || "audio/webm";
      
      // Transcribe audio
      logger.info(`${logPrefix} Transcribing audio (${audioBuffer.length} bytes, type: ${detectedMimeType})`);
      const transcriptionResult = await this.sttService.transcribeAudio(
        audioBuffer,
        userId,
        detectedMimeType
      );
      
      // Extract transcription
      const transcriptionText = transcriptionResult.text;
      logger.info(`${logPrefix} Transcription result: "${transcriptionText.substring(0, 100)}${transcriptionText.length > 100 ? '...' : ''}"`);
      
      // If transcription failed or is empty
      if (!transcriptionText || transcriptionText.trim() === "") {
        logger.warn(`${logPrefix} Empty or failed transcription`);
        return {
          sessionId: sessionId || randomUUID(),
          response: "I couldn't understand what was said in the audio. Could you please try again with clearer audio or send a text message?",
          lang: "en",
          intentType: 'no_transcription',
          workflowFeedback: null,
          structuredData: null,
          audioUrl: null,
          ttsInstructions: null,
          clarificationQuestion: null,
          clarificationDetails: null,
          transcription: "",
          debugInfo: {
            flow_type: 'transcription_empty',
            llmModelUsed: null,
            llmUsage: null,
            latencyMs: 0
          }
        };
      }
      
      // Enrich API context with audio information
      const audioApiContext = {
        ...(apiContext || {}),
        isAudioMessage: true,
        originalAudioUrl: audioUrl,
        transcriptionLanguage: transcriptionResult.language || "en",
        transcriptionConfidence: transcriptionResult.confidence || 0,
        transcriptionModel: transcriptionResult.model || "openai-whisper",
      };
      
      // Process the transcribed text using the existing text message handler
      logger.info(`${logPrefix} Sending transcribed text to processTextMessage`);
      const textResponse = await this.processTextMessage(
        userId,
        transcriptionText,
        history,
        sessionId,
        audioApiContext
      );
      
      // Add transcription to the response
      return {
        ...textResponse,
        transcription: transcriptionText,
        intentType: textResponse.intentType || 'audio_message'
      };
    } catch (error: any) {
      logger.error(`${logPrefix} Error processing audio message:`, error);
      
      return {
        sessionId: sessionId || randomUUID(),
        response: "I encountered an error processing your audio message. Please try again or send a text message instead.",
        lang: "en",
        intentType: 'error',
        workflowFeedback: null,
        structuredData: null,
        audioUrl: null,
        ttsInstructions: null,
        clarificationQuestion: null,
        clarificationDetails: null,
        transcription: null,
        debugInfo: {
          flow_type: 'error',
          llmModelUsed: null,
          llmUsage: null,
          latencyMs: 0,
          error: error.message
        }
      };
    }
  }
}

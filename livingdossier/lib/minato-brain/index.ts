//livingdossier/lib/minato-brain/index.ts

/**
 * Main entry point for the minato-brain
 */

import { analyzeQuery, generatePlaybook, fillTaskParameters, PlaybookTask } from './PlaybookGenerator';
import { executePlaybook, executeTask, executeZeroShotTask, generateDynamicTask, TaskResult } from './ExecutionEngine';
import { synthesizeResults, generateStreamlitDashboard, generateNextJsDashboard, generatePdfReport, SynthesisOptions, SynthesisResult } from './SynthesisEngine';
import { createDossier, updateDossier, getDossier, LivingDossier } from '../../services/database/living_dossier';
import { config } from '../../config/config';
import { PlaybookExecutionContext, QueryAnalysisRequest, QueryAnalysisResponse, GenerateDossierRequest, GenerateDossierResponse } from './types';
import { SemanticMatcher } from './SemanticMatcher';
import { allConcepts, DynamicSemanticConcept } from './ConceptLibrary';
import * as path from 'path';
import { generateStructuredData } from '../../services/llm/openai';

/**
 * Export all components
 */
export {
  analyzeQuery,
  generatePlaybook,
  fillTaskParameters,
  executePlaybook,
  executeTask,
  executeZeroShotTask,
  generateDynamicTask,
  synthesizeResults,
  generateStreamlitDashboard,
  generateNextJsDashboard,
  generatePdfReport
};

/**
 * Export interfaces
 */
export type {
  PlaybookTask,
  TaskResult,
  SynthesisOptions,
  SynthesisResult
};

/**
 * Interface for query analysis and refinement options
 */
export interface QueryRefinementOptions {
  query: string;
  userId: string;
  language?: string;
  maxTokens?: number;
}

/**
 * Interface for dossier generation options
 */
export interface DossierGenerationOptions {
  dossierId: string;
  query: string;
  refinedQuery: string;
  userId: string;
  maxTasks?: number;
  format?: 'streamlit' | 'nextjs' | 'pdf' | 'all';
  includeRawData?: boolean;
}

/**
 * Interface for dossier status
 */
export interface DossierStatus {
  id: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  progress: number;
  streamlitUrl?: string;
  nextjsUrl?: string;
  pdfUrl?: string;
  error?: string;
}

/**
 * Analyze a user query and refine it
 * @param request The query analysis request
 * @returns The query analysis response
 */
export async function analyzeAndRefineQuery(request: QueryAnalysisRequest): Promise<QueryAnalysisResponse> {
  try {
    // Analyze the query
    const analysis = await analyzeQuery(request.query);
    
    // Create a title based on the analysis
    const title = `Living Dossier: ${analysis.topic}`;
    
    // Create a new dossier
    const dossier = await createDossier({
      id: '', // This will be generated by the database
      title,
      user_id: request.userId,
      query: request.query,
      refined_query: request.query, // Initially the same as the query
      status: 'pending' // Add required status field
    });
    
    return {
      dossierId: dossier.id,
      title,
      refinedQuery: request.query
    };
  } catch (error: any) {
    console.error('Error analyzing and refining query:', error);
    throw new Error(`Failed to analyze and refine query: ${error.message}`);
  }
}

/**
 * Generate a dossier based on a query
 * @param request The generate dossier request
 * @returns The generate dossier response
 */
export async function generateDossier(request: GenerateDossierRequest): Promise<GenerateDossierResponse> {
  try {
    // Update the dossier with the refined query
    await updateDossier(request.dossierId, {
      refined_query: request.refinedQuery
    });
    
    // Analyze the refined query
    const analysis = await analyzeQuery(request.refinedQuery);
    
    // Create a semantic matcher instance
    // Convert DynamicSemanticConcept[] to any[] to avoid type errors
    const semanticMatcher = new SemanticMatcher(allConcepts as any[]);
    
    // Expand the concept library with new concepts from the query
    await semanticMatcher.expandConceptLibrary(request.refinedQuery, analysis.language);
    
    // Generate a playbook based on the analysis
    let playbook = await generatePlaybook(analysis);
    
    // If no tasks were selected or the scores are low, generate a dynamic task
    if (playbook.length === 0 || (playbook.length === 1 && playbook[0].id.includes('default'))) {
      console.log('No suitable tasks found, generating dynamic task...');
      const dynamicTask = await generateDynamicTask(request.refinedQuery, analysis.domain);
      playbook = [dynamicTask];
    }
    
    // Fill in the parameters for each task
    const filledPlaybook = playbook.map(task => fillTaskParameters(task, analysis));
    
    // Create the execution context
    const context: PlaybookExecutionContext = {
      dossierId: request.dossierId,
      userId: request.userId,
      query: request.query,
      refinedQuery: request.refinedQuery,
      playbook: filledPlaybook,
      results: [],
      currentTaskIndex: 0,
      status: 'pending'
    };
    
    // Start the execution in the background
    executePlaybookAndSynthesize(context);
    
    return {
      dossierId: request.dossierId,
      status: 'pending'
    };
  } catch (error: any) {
    console.error('Error generating dossier:', error);
    
    // If an error occurs, try to execute a zero-shot task as a fallback
    try {
      console.log('Attempting zero-shot analysis as fallback...');
      const zeroShotResult = await executeZeroShotTask(request.refinedQuery, request.dossierId);
      
      // If the zero-shot task was successful, update the dossier
      if (zeroShotResult.success) {
        await updateDossier(request.dossierId, {
          status: 'completed',
          progress: 100,
          results: [zeroShotResult]
        });
        
        return {
          dossierId: request.dossierId,
          status: 'completed'
        };
      }
    } catch (fallbackError) {
      console.error('Fallback zero-shot analysis also failed:', fallbackError);
    }
    
    // Update the dossier with the error
    await updateDossier(request.dossierId, {
      status: 'failed',
      error: `Failed to generate dossier: ${error.message}`
    });
    
    return {
      dossierId: request.dossierId,
      status: 'failed',
      error: error.message
    };
  }
}

/**
 * Execute a playbook and synthesize the results
 * @param context The playbook execution context
 * @returns The updated context
 */
async function executePlaybookAndSynthesize(context: PlaybookExecutionContext): Promise<PlaybookExecutionContext> {
  try {
    // Update the dossier status to processing
    await updateDossier(context.dossierId, {
      status: 'processing',
      progress: 0
    });
    
    // Execute the playbook
    const results = await executePlaybook(context.playbook, context.dossierId);
    
    // Synthesize the results
    const synthesisResult = await synthesizeResults(results, context.query, context.refinedQuery, context.dossierId);
    
    // Get the updated dossier
    const dossier = await getDossier(context.dossierId);
    
    // Update the context
    context.results = results;
    context.status = 'completed';
    
    // Add null checks for dossier properties
    if (dossier) {
      context.spaUrl = dossier.nextjs_url;
      context.streamlitUrl = dossier.streamlit_url;
    }
    
    return context;
  } catch (error: any) {
    console.error('Error executing playbook and synthesizing results:', error);
    
    // Update the dossier with the error
    await updateDossier(context.dossierId, {
      status: 'failed',
      error: `Failed to execute playbook and synthesize results: ${error.message}`
    });
    
    // Update the context
    context.status = 'failed';
    context.error = error.message;
    
    return context;
  }
}

/**
 * Get the status of a dossier
 * @param dossierId The ID of the dossier
 * @returns The status of the dossier
 */
export async function getDossierStatus(dossierId: string): Promise<GenerateDossierResponse> {
  try {
    const dossier = await getDossier(dossierId);
    
    if (!dossier) {
      throw new Error(`Dossier not found: ${dossierId}`);
    }
    
    return {
      dossierId,
      status: dossier.status,
      spaUrl: dossier.nextjs_url,
      streamlitUrl: dossier.streamlit_url,
      error: dossier.error
    };
  } catch (error: any) {
    console.error('Error getting dossier status:', error);
    throw new Error(`Failed to get dossier status: ${error.message}`);
  }
}

/**
 * Incorporate user feedback to improve the system
 * @param dossierId The ID of the dossier
 * @param feedback The user feedback
 * @param rating Optional rating (1-5)
 * @returns Success status
 */
export async function incorporateFeedback(
  dossierId: string,
  feedback: string,
  rating?: number
): Promise<boolean> {
  try {
    // Get the dossier
    const dossier = await getDossier(dossierId);
    
    if (!dossier) {
      throw new Error(`Dossier not found: ${dossierId}`);
    }
    
    // Create a semantic matcher instance
    const semanticMatcher = new SemanticMatcher(allConcepts as any[]);
    
    // Define the insights interface
    interface FeedbackInsights {
      missing_concepts?: Array<{
        name: string;
        keywords: string[];
        domain: string;
      }>;
      task_improvements?: Array<{
        task_type: string;
        suggestion: string;
      }>;
      new_triggers?: Array<{
        keyword: string;
        task_types: string[];
      }>;
    }
    
    // Extract insights from the feedback
    const prompt = `
Analyze this user feedback for a Living Dossier report:

Dossier Topic: "${dossier.title}"
Original Query: "${dossier.query}"
User Feedback: "${feedback}"
${rating ? `User Rating: ${rating}/5` : ''}

Extract insights that can help improve our system:
1. What concepts or domains were missing or inadequately covered?
2. What specific improvements could be made to task definitions?
3. What new keywords or triggers should be added to our strategy components?

Return a structured JSON object with:
{
  "missing_concepts": [
    {
      "name": "Concept Name",
      "keywords": ["keyword1", "keyword2"],
      "domain": "The domain this concept belongs to"
    }
  ],
  "task_improvements": [
    {
      "task_type": "Type of task that needs improvement",
      "suggestion": "Specific improvement suggestion"
    }
  ],
  "new_triggers": [
    {
      "keyword": "New trigger keyword",
      "task_types": ["Types of tasks this keyword should trigger"]
    }
  ]
}
`;

    const insights = await generateStructuredData<FeedbackInsights>(prompt);
    
    // Add new concepts to the library
    if (insights.missing_concepts && insights.missing_concepts.length > 0) {
      for (const concept of insights.missing_concepts) {
        await semanticMatcher.expandConceptLibrary(concept.name, 'en');
      }
      
      // Save the expanded concept library
      const conceptLibraryPath = path.resolve(__dirname, './expanded-concepts.ts');
      await semanticMatcher.saveConceptLibrary(conceptLibraryPath);
    }
    
    // Store the feedback and insights
    await updateDossier(dossierId, {
      progress: 100,
      results: [...(dossier.results || []), {
        user_feedback: feedback,
        user_rating: rating,
        feedback_insights: insights
      }]
    });
    
    return true;
  } catch (error) {
    console.error('Error incorporating feedback:', error);
    return false;
  }
}

//The Master Orchestrator (The CEO)
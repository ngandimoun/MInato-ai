Cloud API
Quickstart
Learn how to get started with the Browser Use Cloud API

The Browser Use Cloud API lets you create and manage browser automation agents programmatically. Each agent can execute tasks and provide real-time feedback through a live preview URL.



Creating Your First Agent
Create a new browser automation task by providing instructions in natural language:


Copy

Ask AI
curl -X POST https://api.browser-use.com/api/v1/run-task \
  -H "Authorization: Bearer your_api_key_here" \
  -H "Content-Type: application/json" \
  -d '{
    "task": "Go to google.com and search for Browser Use"
  }'
The API returns a task ID that you can use to manage the task and check the live preview URL.





For detailed API documentation, see the tabs on the left, which include the full coverage of the API.

​
Building your own client (OpenAPI)
We recommend this only if you don’t need control and only need to run simple tasks.

The best way to build your own client is to use our OpenAPI specification to generate a type-safe client library.




TypeScript/JavaScript
For TypeScript projects, use openapi-typescript to generate type definitions:


Copy

Ask AI
# Install the generator
npm install -D openapi-typescript

# Generate the types
npx openapi-typescript http://api.browser-use.com/openapi.json -o browser-use-api.ts
This will create TypeScript definitions you can use with your preferred HTTP client.

Need help? Contact our support team at support@browser-use.com or join our Discord community





Python
Use openapi-python-client to generate a modern Python client:


Copy

Ask AI
# Install the generator
pipx install openapi-python-client --include-deps

# Generate the client
openapi-python-client generate --url http://api.browser-use.com/openapi.json
This will create a Python package with full type hints, modern dataclasses, and async support.





Cloud API
Implementing the API
Learn how to implement the Browser Use API in Python

This guide shows how to implement common API patterns using Python. We’ll create a complete example that creates and monitors a browser automation task.

​
Basic Implementation
For all settings see Run Task.

Here’s a simple implementation using Python’s requests library to stream the task steps:


Copy

Ask AI
import json
import time

import requests

API_KEY = 'your_api_key_here'
BASE_URL = 'https://api.browser-use.com/api/v1'
HEADERS = {'Authorization': f'Bearer {API_KEY}'}


def create_task(instructions: str):
	"""Create a new browser automation task"""
	response = requests.post(f'{BASE_URL}/run-task', headers=HEADERS, json={'task': instructions})
	return response.json()['id']


def get_task_status(task_id: str):
	"""Get current task status"""
	response = requests.get(f'{BASE_URL}/task/{task_id}/status', headers=HEADERS)
	return response.json()


def get_task_details(task_id: str):
	"""Get full task details including output"""
	response = requests.get(f'{BASE_URL}/task/{task_id}', headers=HEADERS)
	return response.json()


def wait_for_completion(task_id: str, poll_interval: int = 2):
	"""Poll task status until completion"""
	count = 0
	unique_steps = []
	while True:
		details = get_task_details(task_id)
		new_steps = details['steps']
		# use only the new steps that are not in unique_steps.
		if new_steps != unique_steps:
			for step in new_steps:
				if step not in unique_steps:
					print(json.dumps(step, indent=4))
			unique_steps = new_steps
		count += 1
		status = details['status']

		if status in ['finished', 'failed', 'stopped']:
			return details
		time.sleep(poll_interval)


def main():
	task_id = create_task('Open https://www.google.com and search for openai')
	print(f'Task created with ID: {task_id}')
	task_details = wait_for_completion(task_id)
	print(f"Final output: {task_details['output']}")


if __name__ == '__main__':
	main()

​
Task Control Example
Here’s how to implement task control with pause/resume functionality:


Copy

Ask AI
def control_task():
    # Create a new task
    task_id = create_task("Go to google.com and search for Browser Use")

    # Wait for 5 seconds
    time.sleep(5)

    # Pause the task
    requests.put(f"{BASE_URL}/pause-task?task_id={task_id}", headers=HEADERS)
    print("Task paused! Check the live preview.")

    # Wait for user input
    input("Press Enter to resume...")

    # Resume the task
    requests.put(f"{BASE_URL}/resume-task?task_id={task_id}", headers=HEADERS)

    # Wait for completion
    result = wait_for_completion(task_id)
    print(f"Task completed with output: {result['output']}")
​
Structured Output Example
Here’s how to implement a task with structured JSON output:


Copy

Ask AI
import json
import os
import time
import requests
from pydantic import BaseModel
from typing import List


API_KEY = os.getenv("API_KEY")
BASE_URL = 'https://api.browser-use.com/api/v1'
HEADERS = {
    "Authorization": f"Bearer {API_KEY}",
    "Content-Type": "application/json"
}


# Define output schema using Pydantic
class SocialMediaCompany(BaseModel):
    name: str
    market_cap: float
    headquarters: str
    founded_year: int


class SocialMediaCompanies(BaseModel):
    companies: List[SocialMediaCompany]


def create_structured_task(instructions: str, schema: dict):
    """Create a task that expects structured output"""
    payload = {
        "task": instructions,
        "structured_output_json": json.dumps(schema)
    }
    response = requests.post(f"{BASE_URL}/run-task", headers=HEADERS, json=payload)
    response.raise_for_status()
    return response.json()["id"]


def wait_for_task_completion(task_id: str, poll_interval: int = 5):
    """Poll task status until it completes"""
    while True:
        response = requests.get(f"{BASE_URL}/task/{task_id}/status", headers=HEADERS)
        response.raise_for_status()
        status = response.json()
        if status == "finished":
            break
        elif status in ["failed", "stopped"]:
            raise RuntimeError(f"Task {task_id} ended with status: {status}")
        print("Waiting for task to finish...")
        time.sleep(poll_interval)


def fetch_task_output(task_id: str):
    """Retrieve the final task result"""
    response = requests.get(f"{BASE_URL}/task/{task_id}", headers=HEADERS)
    response.raise_for_status()
    return response.json()["output"]


def main():
    schema = SocialMediaCompanies.model_json_schema()
    task_id = create_structured_task(
        "Get me the top social media companies by market cap",
        schema
    )
    print(f"Task created with ID: {task_id}")

    wait_for_task_completion(task_id)
    print("Task completed!")

    output = fetch_task_output(task_id)
    print("Raw output:", output)

    try:
        parsed = SocialMediaCompanies.model_validate_json(output)
        print("Parsed output:")
        print(parsed)
    except Exception as e:
        print(f"Failed to parse structured output: {e}")


if __name__ == "__main__":
    main()
Remember to handle your API key securely and implement proper error handling in production code.






Cloud API
Webhooks
Learn how to integrate webhooks with Browser Use Cloud API

Webhooks allow you to receive real-time notifications about events in your Browser Use tasks. This guide will show you how to set up and verify webhook endpoints.

​
Prerequisites
You need an active subscription to create webhooks. See your billing page cloud.browser-use.com/billing





Setting Up Webhooks
To receive webhook notifications, you need to:

Create an endpoint that can receive HTTPS POST requests
Configure your webhook URL in the Browser Use dashboard
Implement signature verification to ensure webhook authenticity
When adding a webhook URL in the dashboard, it must be a valid HTTPS URL that can receive POST requests. On creation, we will send a test payload {"type": "test", "timestamp": "2024-03-21T12:00:00Z", "payload": {"test": "ok"}} to verify the endpoint is working correctly before creating the actual webhook!





Webhook Events
Browser Use sends various types of events. Each event has a specific type and payload structure.

​
Event Types
Currently supported events





Task Status Updates
The agent.task.status_update event includes the following statuses




Webhook Payload Structure
Each webhook call includes:

A JSON payload with event details
X-Browser-Use-Timestamp header with the current timestamp
X-Browser-Use-Signature header for verification
The payload follows this structure:


Copy

Ask AI
{
  "type": "agent.task.status_update",
  "timestamp": "2025-05-25T09:22:22.269116+00:00",
  "payload": {
    "session_id": "cd9cc7bf-e3af-4181-80a2-73f083bc94b4",
    "task_id": "5b73fb3f-a3cb-4912-be40-17ce9e9e1a45",
    "status": "finished"
  }
}








Implementing Webhook Verification
To ensure webhook authenticity, you must verify the signature. Here’s an example implementation in Python using FastAPI:


Copy

Ask AI
import uvicorn
import hmac
import hashlib
import json
import os

from fastapi import FastAPI, Request, HTTPException

app = FastAPI()

SECRET_KEY = os.environ['SECRET_KEY']

def verify_signature(payload: dict, timestamp: str, received_signature: str) -> bool:
    message = f'{timestamp}.{json.dumps(payload, separators=(",", ":"), sort_keys=True)}'
    expected_signature = hmac.new(SECRET_KEY.encode(), message.encode(), hashlib.sha256).hexdigest()
    return hmac.compare_digest(expected_signature, received_signature)

@app.post('/webhook')
async def webhook(request: Request):
    body = await request.json()

    timestamp = request.headers.get('X-Browser-Use-Timestamp')
    signature = request.headers.get('X-Browser-Use-Signature')
    if not timestamp or not signature:
        raise HTTPException(status_code=400, detail='Missing timestamp or signature')

    if not verify_signature(body, timestamp, signature):
        raise HTTPException(status_code=403, detail='Invalid signature')

    # Handle different event types
    event_type = body.get('type')
    if event_type == 'agent.task.status_update':
        # Handle task status update
        print('Task status update received:', body['payload'])
    elif event_type == 'test':
        # Handle test webhook
        print('Test webhook received:', body['payload'])
    else:
        print('Unknown event type:', event_type)

    return {'status': 'success', 'message': 'Webhook received'}

if __name__ == '__main__':
    uvicorn.run(app, host='0.0.0.0', port=8080)




Best Practices
Always verify signatures: Never process webhook payloads without verifying the signature
Handle retries: Browser Use will retry failed webhook deliveries up to 5 times
Respond quickly: Return a 200 response as soon as you’ve verified the signature
Process asynchronously: Handle the webhook payload processing in a background task
Monitor failures: Set up monitoring for webhook delivery failures
Handle unknown events: Implement graceful handling of new event types that may be added in the future
Need help? Contact our support team at support@browser-use.com or join our Discord community








API v1.0
Run Task
Requires an active subscription. Returns the task ID that can be used to track progress.

Try it
Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

Body
application/json
task: What should the agent do. You can try it out at https://cloud.browser-use.com/

secrets: Dictionary of secrets to be used by the agent. Secrets are safely encrypted before storing in the database.

allowed_domains: List of domains that the agent is allowed to visit. If not set, the agent will be allowed to visit all domains (not recommended if you are using secrets).

save_browser_data: If set to True, the browser cookies and other data will be saved. Cookies are safely encrypted before storing in the database.

structured_output_json: If set, the agent will use this JSON schema as the output model (see example here: https://docs.browser-use.com/cloud/implementation#structured-output-example).

use_adblock: If set to True, the agent will use an adblocker.

use_proxy: If set to True, the agent will use a (mobile) proxy. Note that proxy is required for captcha solving, so if you disable proxy, you will not be able to solve captchas.

proxy_country_code: Country code for residential proxy. Must be one of: 'us', 'fr', 'it', 'jp', 'au', 'de', 'fi', 'ca'. Default is 'us'.

highlight_elements: If set to True, the agent will highlight the elements on the page.

included_file_names: File names to include in the task (note: use uploads/presigned-url endpoint to upload the files first!). E.g. ['file1.txt', 'file2.csv'].



import requests

url = "https://api.browser-use.com/api/v1/run-task"

payload = {
    "task": "<string>",
    "secrets": {},
    "allowed_domains": ["<string>"],
    "save_browser_data": True,
    "structured_output_json": "<string>",
    "llm_model": "gpt-4o",
    "use_adblock": True,
    "use_proxy": True,
    "proxy_country_code": "us",
    "highlight_elements": True,
    "included_file_names": ["<string>"]
}
headers = {
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.request("POST", url, json=payload, headers=headers)

print(response.text)



const options = {
  method: 'POST',
  headers: {Authorization: 'Bearer <token>', 'Content-Type': 'application/json'},
  body: '{"task":"<string>","secrets":{},"allowed_domains":["<string>"],"save_browser_data":true,"structured_output_json":"<string>","llm_model":"gpt-4o","use_adblock":true,"use_proxy":true,"proxy_country_code":"us","highlight_elements":true,"included_file_names":["<string>"]}'
};

fetch('https://api.browser-use.com/api/v1/run-task', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));





Stop Task
Stops a running browser automation task immediately. The task cannot be resumed after being stopped. Use /pause-task endpoint instead if you want to temporarily halt execution.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.


const options = {method: 'PUT', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/stop-task', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));


import requests

url = "https://api.browser-use.com/api/v1/stop-task"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("PUT", url, headers=headers)

print(response.text)




Pause Task
Pauses execution of a running task. The task can be resumed later using the /resume-task endpoint. Useful for manual intervention or inspection.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.


import requests

url = "https://api.browser-use.com/api/v1/pause-task"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("PUT", url, headers=headers)

print(response.text)


const options = {method: 'PUT', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/pause-task', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));




Resume Task
Resumes execution of a previously paused task. The task will continue from where it was paused. You can’t resume a stopped task.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.



const options = {method: 'PUT', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/resume-task', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));

import requests

url = "https://api.browser-use.com/api/v1/resume-task"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("PUT", url, headers=headers)

print(response.text)


Get Task
Returns comprehensive information about a task, including its current status, steps completed, output (if finished), and other metadata.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

import requests

url = "https://api.browser-use.com/api/v1/task/{task_id}"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)


const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/task/{task_id}', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));



Successful Response

output: Final output or result of the task (if completed)
live_url: URL to view live task execution. To preview the url you can directly integrate it in <iframe> tag. For example:
<iframe src={live_url} width="600" height="450"></iframe>
Which will display the task execution and allows you to control the agent live. It is pure VNC implementation.

browser_data: Browser session data from the task (cookies). To enable this feature, you need to set save_browser_data = True in the request.

Enumeration of possible task states.

created: Task is initialized but not yet started
running: Task is currently executing
finished: Task has completed successfully
stopped: Task was manually stopped
paused: Task execution is temporarily paused
failed: Task encountered an error and could not complete
Available options: created, running, finished, stopped, paused, failed 

cookies: List of cookies from the browser session

This field is only available if save_browser_data is set to True in the request.





Get Task Status
Returns just the current status of a task (created, running, finished, stopped, or paused). More lightweight than the full task details endpoint.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

Successful Response

Enumeration of possible task states.

created: Task is initialized but not yet started
running: Task is currently executing
finished: Task has completed successfully
stopped: Task was manually stopped
paused: Task execution is temporarily paused
failed: Task encountered an error and could not complete
Available options: created, running, finished, stopped, paused, failed

const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/task/{task_id}/status', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));

import requests

url = "https://api.browser-use.com/api/v1/task/{task_id}/status"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)






Get Task Media
Returns links to any recordings or media generated during task execution, such as browser session recordings. Only available for completed tasks.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

import requests

url = "https://api.browser-use.com/api/v1/task/{task_id}/media"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)


const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/task/{task_id}/media', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));


Get Task Screenshots
Returns any screenshot urls generated during task execution.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/task/{task_id}/screenshots', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));

import requests

url = "https://api.browser-use.com/api/v1/task/{task_id}/screenshots"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)





Get Task Gif
Returns a gif url generated from the screenshots of the task execution. Only available for completed tasks that have screenshots.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

import requests

url = "https://api.browser-use.com/api/v1/task/{task_id}/gif"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)



const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/task/{task_id}/gif', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));



Get Task Output File
Returns a presigned url for downloading a file from the task output files.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

Successful Response

download_url: Presigned URL for downloading the output file.

const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/task/{task_id}/output-file/{file_name}', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));



import requests

url = "https://api.browser-use.com/api/v1/task/{task_id}/output-file/{file_name}"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)




List Tasks
Returns a paginated list of all tasks belonging to the user, ordered by creation date. Each task includes basic information like status and creation time. For detailed task info, use the get task endpoint.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

Successful Response

total_pages: Total number of pages available
page: Current page number
limit: Number of items per page
total_count: Total number of tasks across all pages

import requests

url = "https://api.browser-use.com/api/v1/tasks"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)


const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/tasks', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));


Upload File Presigned Url
Returns a presigned url for uploading a file to the user’s files bucket. After uploading a file, the user can use the included_file_names field in the RunTaskRequest to include the files in the task.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

Body
application/json
file_name: Name of the file to upload (e.g. 'file1.txt', 'file2.csv').
content_type: Content type of the file to upload (e.g. 'image/png', 'application/pdf', 'text/plain'). Only images and documents are supported.

Response
200

200
application/json
Successful Response

upload_url: Presigned URL for uploading a file to the user's files bucket.

Note: Make a PUT presigned URL request to upload the file.


const options = {
  method: 'POST',
  headers: {Authorization: 'Bearer <token>', 'Content-Type': 'application/json'},
  body: '{"file_name":"<string>","content_type":"<string>"}'
};

fetch('https://api.browser-use.com/api/v1/uploads/presigned-url', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));


import requests

url = "https://api.browser-use.com/api/v1/uploads/presigned-url"

payload = {
    "file_name": "<string>",
    "content_type": "<string>"
}
headers = {
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.request("POST", url, json=payload, headers=headers)

print(response.text)




Create Scheduled Task
Create a scheduled task to run at regular intervals or based on a cron expression. Requires an active subscription. Returns the scheduled task ID.


Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

Body
application/json
schedule_type: Type of schedule to use (interval or cron)
interval_minutes: Minutes between runs (required for interval schedule)
cron_expression: Cron expression for scheduling (required for cron schedule)
start_at: When to start the schedule (optional, defaults to now)
end_at: When to end the schedule (optional, defaults to 1 year from now)

Note: Secrets are not yet supported for scheduled tasks.

import requests

url = "https://api.browser-use.com/api/v1/scheduled-task"

payload = {
    "task": "<string>",
    "secrets": {},
    "allowed_domains": ["<string>"],
    "save_browser_data": True,
    "structured_output_json": "<string>",
    "llm_model": "gpt-4o",
    "use_adblock": True,
    "use_proxy": True,
    "proxy_country_code": "us",
    "highlight_elements": True,
    "included_file_names": ["<string>"],
    "schedule_type": "interval",
    "interval_minutes": 123,
    "cron_expression": "<string>",
    "start_at": "2023-11-07T05:31:56Z",
    "end_at": "2023-11-07T05:31:56Z"
}
headers = {
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.request("POST", url, json=payload, headers=headers)

print(response.text)



const options = {
  method: 'POST',
  headers: {Authorization: 'Bearer <token>', 'Content-Type': 'application/json'},
  body: '{"task":"<string>","secrets":{},"allowed_domains":["<string>"],"save_browser_data":true,"structured_output_json":"<string>","llm_model":"gpt-4o","use_adblock":true,"use_proxy":true,"proxy_country_code":"us","highlight_elements":true,"included_file_names":["<string>"],"schedule_type":"interval","interval_minutes":123,"cron_expression":"<string>","start_at":"2023-11-07T05:31:56Z","end_at":"2023-11-07T05:31:56Z"}'
};

fetch('https://api.browser-use.com/api/v1/scheduled-task', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));


List Scheduled Tasks
Returns a paginated list of all scheduled tasks belonging to the user, ordered by creation date. Each task includes basic information like schedule type, next run time, and status.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/scheduled-tasks', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));



import requests

url = "https://api.browser-use.com/api/v1/scheduled-tasks"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)


Get Scheduled Task
Returns detailed information about a specific scheduled task, including its schedule configuration and current status.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.


import requests

url = "https://api.browser-use.com/api/v1/scheduled-task/{task_id}"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)

const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/scheduled-task/{task_id}', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));


Update Scheduled Task
Update a scheduled task with partial updates.

const options = {
  method: 'PUT',
  headers: {Authorization: 'Bearer <token>', 'Content-Type': 'application/json'},
  body: '{"task":"<string>","schedule_type":"interval","interval_minutes":123,"cron_expression":"<string>","start_at":"2023-11-07T05:31:56Z","end_at":"2023-11-07T05:31:56Z","is_active":true,"use_adblock":true,"use_proxy":true,"highlight_elements":true,"llm_model":"gpt-4o","save_browser_data":true,"structured_output_json":"<string>"}'
};

fetch('https://api.browser-use.com/api/v1/scheduled-task/{task_id}', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));

import requests

url = "https://api.browser-use.com/api/v1/scheduled-task/{task_id}"

payload = {
    "task": "<string>",
    "schedule_type": "interval",
    "interval_minutes": 123,
    "cron_expression": "<string>",
    "start_at": "2023-11-07T05:31:56Z",
    "end_at": "2023-11-07T05:31:56Z",
    "is_active": True,
    "use_adblock": True,
    "use_proxy": True,
    "highlight_elements": True,
    "llm_model": "gpt-4o",
    "save_browser_data": True,
    "structured_output_json": "<string>"
}
headers = {
    "Authorization": "Bearer <token>",
    "Content-Type": "application/json"
}

response = requests.request("PUT", url, json=payload, headers=headers)

print(response.text)




Delete Scheduled Task
Deletes a scheduled task. This will prevent any future runs of this task. Any currently running instances of this task will be allowed to complete.

import requests

url = "https://api.browser-use.com/api/v1/scheduled-task/{task_id}"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("DELETE", url, headers=headers)

print(response.text)


const options = {method: 'DELETE', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/scheduled-task/{task_id}', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));



Delete Browser Profile For User
Deletes the browser profile for the user.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

const options = {method: 'POST', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/delete-browser-profile-for-user', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));


import requests

url = "https://api.browser-use.com/api/v1/delete-browser-profile-for-user"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("POST", url, headers=headers)

print(response.text)



Check Balance
Returns the user’s current API credit balance, which includes both monthly subscription credits and any additional purchased credits. Required for monitoring usage and ensuring sufficient credits for task execution.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.


import requests

url = "https://api.browser-use.com/api/v1/balance"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)



const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/balance', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));


Me
Returns a boolean value indicating if the API key is valid and the user is authenticated.

Authorizations
​
Authorization
stringheaderrequired
Bearer authentication header of the form Bearer <token>, where <token> is your auth token.

const options = {method: 'GET', headers: {Authorization: 'Bearer <token>'}};

fetch('https://api.browser-use.com/api/v1/me', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));


import requests

url = "https://api.browser-use.com/api/v1/me"

headers = {"Authorization": "Bearer <token>"}

response = requests.request("GET", url, headers=headers)

print(response.text)


Ping
Use this endpoint to check if the server is running and responding.


import requests

url = "https://api.browser-use.com/api/v1/ping"

response = requests.request("GET", url)

print(response.text)


const options = {method: 'GET'};

fetch('https://api.browser-use.com/api/v1/ping', options)
  .then(response => response.json())
  .then(response => console.log(response))
  .catch(err => console.error(err));